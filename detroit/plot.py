# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class Plot_:
    """
    Class which mimick :code:`Plot`

    See `documentation <https://observablehq.com/plot/getting-started>`_.

    Examples
    --------

    >>> from detroit import Plot, js
    >>> Plot.dot(js("data"), {
    ...     "x": "Component 1",
    ...     "y": "Component 2",
    ...     "stroke": "digit",
    ...     "symbol": "digit",
    ... }).plot({
    ...     "symbol": {"legend": js("true")},
    ...     "color": {"scheme": "rainbow"},
    ... })
    Plot.dot(data, {'x': 'Component 1', 'y': 'Component 2', 'stroke': 'digit', 'symbol': 'digit'}).plot({'symbol': {'legend': true}, 'color': {'scheme': 'rainbow'}})

    Notes
    -----
    Do not use directly this class. Instead use :code:`detroit.Plot` or :code:`Plot = detroit.plot.Plot_()`.
    """
    def __init__(self, content: str = "Plot"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def area(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})
            
        Returns a new area with the given data and options. This method is rarely used
        directly; it is only needed when the baseline and topline have neither common x nor y
        values. areaY is used in the common horizontal orientation where the baseline and
        topline share x values, while areaX is used in the vertical orientation where the
        baseline and topline share y values.
        See more informations `here` <https://observablehq.com/plot/marks/area#area>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.area({arguments})")


    def areaX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.areaX(aapl, {y: "Date", x: "Close"})
            
        Returns a new area with the given data and options. This constructor is used when the
        baseline and topline share y values, as in a time-series area chart where time goes
        up↑. If neither the x1 nor x2 option is specified, the x option may be specified as
        shorthand to apply an implicit stackX transform; this is the typical configuration for
        an area chart with a baseline at x = 0. If the x option is not specified, it defaults
        to the identity function. The y option specifies the y1 channel; and the y1 and y2
        options are ignored.
        If the interval option is specified, the binY transform is implicitly applied to the
        specified options. The reducer of the output x channel may be specified via the reduce
        option, which defaults to first. To default to zero instead of showing gaps in data, as
        when the observed value represents a quantity, use the sum reducer.
        .. code:: javascript
        
            Plot.areaX(observations, {y: "date", x: "temperature", interval: "day"})
            
        The interval option is recommended to “regularize” sampled data; for example, if your
        data represents timestamped temperature measurements and you expect one sample per day,
        use "day" as the interval.
        See more informations `here` <https://observablehq.com/plot/marks/area#areaX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.areaX({arguments})")


    def areaY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.areaY(aapl, {x: "Date", y: "Close"})
            
        Returns a new area with the given data and options. This constructor is used when the
        baseline and topline share x values, as in a time-series area chart where time goes
        right→. If neither the y1 nor y2 option is specified, the y option may be specified as
        shorthand to apply an implicit stackY transform; this is the typical configuration for
        an area chart with a baseline at y = 0. If the y option is not specified, it defaults
        to the identity function. The x option specifies the x1 channel; and the x1 and x2
        options are ignored.
        If the interval option is specified, the binX transform is implicitly applied to the
        specified options. The reducer of the output y channel may be specified via the reduce
        option, which defaults to first. To default to zero instead of showing gaps in data, as
        when the observed value represents a quantity, use the sum reducer.
        .. code:: javascript
        
            Plot.areaY(observations, {x: "date", y: "temperature", interval: "day"})
            
        The interval option is recommended to “regularize” sampled data; for example, if your
        data represents timestamped temperature measurements and you expect one sample per day,
        use "day" as the interval.
        The areaY mark draws the region between a baseline (y1) and a topline (y2) as in an
        area chart. When the baseline is y = 0, the y channel can be specified instead of y1
        and y2. For example, here is an area chart of Apple’s stock price.
        See more informations `here` <https://observablehq.com/plot/marks/area#areaY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.areaY({arguments})")


    def arrow(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.arrow(inequality, {x1: "POP_1980", y1: "R90_10_1980", x2: "POP_2015", y2: "R90_10_2015", bend: true})
            
        Returns a new arrow with the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/arrow#arrow>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.arrow({arguments})")


    def auto(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.auto(olympians, {x: "weight", y: "height", color: "count"}) // equivalent to rect + bin, say
            
        Returns an automatically-chosen mark with the given data and options, suitable for a
        quick view of the data.
        See more informations `here` <https://observablehq.com/plot/marks/auto#auto>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.auto({arguments})")


    def autoSpec(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.autoSpec(olympians, {x: "weight", y: "height", color: "count"})
            
        Returns an auto mark options object with no option undefined; the mark type, reducers,
        and other options are all populated.
        See more informations `here` <https://observablehq.com/plot/marks/auto#autoSpec>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.autoSpec({arguments})")


    def axisFx(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.axisFx({anchor: "top", label: null})
            
        Returns a new fx axis with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/axis#axisFx>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.axisFx({arguments})")


    def axisFy(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.axisFy({anchor: "right", label: null})
            
        Returns a new fy axis with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/axis#axisFy>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.axisFy({arguments})")


    def axisX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.axisX({anchor: "bottom", tickSpacing: 80})
            
        Returns a new x axis with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/axis#axisX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.axisX({arguments})")


    def axisY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.axisY({anchor: "left", tickSpacing: 35})
            
        Returns a new y axis with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/axis#axisY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.axisY({arguments})")


    def barX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.barX(alphabet, {y: "letter", x: "frequency"})
            
        Returns a new horizontal→ bar with the given data and options. The following channels
        are required:
        The following optional channels are supported:
        If neither the x1 nor x2 option is specified, the x option may be specified as
        shorthand to apply an implicit stackX transform; this is the typical configuration for
        a horizontal bar chart with bars aligned at x = 0. If the x option is not specified, it
        defaults to identity. If options is undefined, then it defaults to x2 as identity and y
        as the zero-based index [0, 1, 2, …]; this allows an array of numbers to be passed to
        barX to make a quick sequential bar chart. If the y channel is not specified, the bar
        will span the full vertical extent of the plot (or facet).
        If an interval is specified, such as d3.utcDay, x1 and x2 can be derived from x:
        interval.floor(x) is invoked for each x to produce x1, and interval.offset(x1) is
        invoked for each x1 to produce x2. If the interval is specified as a number n, x1 and
        x2 are taken as the two consecutive multiples of n that bracket x. Named UTC intervals
        such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/bar#barX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.barX({arguments})")


    def barY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.barY(alphabet, {x: "letter", y: "frequency"})
            
        Returns a new vertical↑ bar with the given data and options. The following channels are
        required:
        The following optional channels are supported:
        If neither the y1 nor y2 option is specified, the y option may be specified as
        shorthand to apply an implicit stackY transform; this is the typical configuration for
        a vertical bar chart with bars aligned at y = 0. If the y option is not specified, it
        defaults to identity. If options is undefined, then it defaults to y2 as identity and x
        as the zero-based index [0, 1, 2, …]; this allows an array of numbers to be passed to
        barY to make a quick sequential bar chart. If the x channel is not specified, the bar
        will span the full horizontal extent of the plot (or facet).
        If an interval is specified, such as d3.utcDay, y1 and y2 can be derived from y:
        interval.floor(y) is invoked for each y to produce y1, and interval.offset(y1) is
        invoked for each y1 to produce y2. If the interval is specified as a number n, y1 and
        y2 are taken as the two consecutive multiples of n that bracket y. Named UTC intervals
        such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/bar#barY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.barY({arguments})")


    def bin(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.rect(olympians, Plot.bin({fill: "count"}, {x: "weight", y: "height"}))
            
        Bins on x and y. Also groups on the first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/bin#bin>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.bin({arguments})")


    def binX(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight"}))
            
        Bins on x. Also groups on y and the first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/bin#binX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.binX({arguments})")


    def binY(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.rectX(olympians, Plot.binY({x: "count"}, {y: "weight"}))
            
        Bins on y. Also groups on x and first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/bin#binY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.binY({arguments})")


    def bollinger(self, options=None):
        """
        .. code:: javascript
        
            Plot.lineY(data, Plot.map({y: Plot.bollinger({n: 20})}, {x: "Date", y: "Close"}))
            
        Returns a bollinger map method for use with the map transform. The k option here
        defaults to zero instead of two.
        See more informations `here` <https://observablehq.com/plot/marks/bollinger#bollinger>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.bollinger({arguments})")


    def bollingerX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.bollingerX(aapl, {y: "Date", x: "Close"})
            
        Returns a bollinger mark for when time goes up↑ (or down↓). If the x option is not
        specified, it defaults to the identity function, as when data is an array of numbers
        [x₀, x₁, x₂, …]. If the y option is not specified, it defaults to [0, 1, 2, …].
        See more informations `here` <https://observablehq.com/plot/marks/bollinger#bollingerX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.bollingerX({arguments})")


    def bollingerY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.bollingerY(aapl, {x: "Date", y: "Close"})
            
        Returns a bollinger mark for when time goes right→ (or ←left). If the y option is not
        specified, it defaults to the identity function, as when data is an array of numbers
        [y₀, y₁, y₂, …]. If the x option is not specified, it defaults to [0, 1, 2, …].
        See more informations `here` <https://observablehq.com/plot/marks/bollinger#bollingerY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.bollingerY({arguments})")


    def boxX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.boxX(simpsons.map((d) => d.imdb_rating))
            
        Returns a horizontal box mark. If the x option is not specified, it defaults to the
        identity function, as when data is an array of numbers. If the y option is not
        specified, it defaults to null; if the y option is specified, it should represent an
        ordinal (discrete) value.
        See more informations `here` <https://observablehq.com/plot/marks/box#boxX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.boxX({arguments})")


    def boxY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.boxY(simpsons.map((d) => d.imdb_rating))
            
        Returns a vertical box mark. If the y option is not specified, it defaults to the
        identity function, as when data is an array of numbers. If the x option is not
        specified, it defaults to null; if the x option is specified, it should represent an
        ordinal (discrete) value.
        See more informations `here` <https://observablehq.com/plot/marks/box#boxY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.boxY({arguments})")


    def cell(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.cell(simpsons, {x: "number_in_season", y: "season", fill: "imdb_rating"})
            
        Returns a new cell with the given data and options. If neither the x nor y options are
        specified, data is assumed to be an array of pairs [[x₀, y₀], [x₁, y₁], [x₂, y₂], …]
        such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/cell#cell>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.cell({arguments})")


    def cellX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.cellX(simpsons.map((d) => d.imdb_rating))
            
        Equivalent to cell, except that if the x option is not specified, it defaults to [0, 1,
        2, …], and if the fill option is not specified and stroke is not a channel, the fill
        defaults to the identity function and assumes that data = [x₀, x₁, x₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/cell#cellX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.cellX({arguments})")


    def cellY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.cellY(simpsons.map((d) => d.imdb_rating))
            
        Equivalent to cell, except that if the y option is not specified, it defaults to [0, 1,
        2, …], and if the fill option is not specified and stroke is not a channel, the fill
        defaults to the identity function and assumes that data = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/cell#cellY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.cellY({arguments})")


    def centroid(self, options=None):
        """
        .. code:: javascript
        
            Plot.centroid({geometry: Plot.identity})
            
        The centroid initializer derives x and y channels representing the planar (projected)
        centroids for the given GeoJSON geometry. If the geometry option is not specified, the
        mark’s data is assumed to be GeoJSON objects.
        See more informations `here` <https://observablehq.com/plot/transforms/centroid#centroid>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.centroid({arguments})")


    def circle(self, data=None, options=None):
        """
        Equivalent to dot except that the symbol option is set to circle.
        See more informations `here` <https://observablehq.com/plot/marks/dot#circle>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.circle({arguments})")


    def cluster(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.cluster(flare, {path: "name", delimiter: "."})
            
        Like tree, except sets the treeLayout option to d3.cluster, aligning leaf nodes, and
        defaults the textLayout option to mirrored.
        See more informations `here` <https://observablehq.com/plot/marks/tree#cluster>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.cluster({arguments})")


    def column(self, source=None):
        """
        .. code:: javascript
        
            const [X, setX] = Plot.column();
            
        This helper for constructing derived columns returns a [column, setColumn] array. The
        column object implements column.transform, returning whatever value was most recently
        passed to setColumn. If setColumn is not called, then column.transform returns
        undefined. If a source is specified, then column.label exposes the given source’s
        label, if any: if source is a string as when representing a named field of data, then
        column.label is source; otherwise column.label propagates source.label. This allows
        derived columns to propagate a human-readable axis or legend label.
        This method is used by Plot’s transforms to derive channels; the associated columns are
        populated (derived) when the transform option function is invoked.
        See more informations `here` <https://observablehq.com/plot/features/transforms#column>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (source,))))
        return Plot_(f"{self.content}.column({arguments})")


    def contour(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.contour(volcano.values, {width: volcano.width, height: volcano.height, fill: Plot.identity})
            
        Returns a new contour mark with the given (optional) data and options.
        See more informations `here` <https://observablehq.com/plot/marks/contour#contour>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.contour({arguments})")


    def crosshair(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.crosshair(cars, {x: "economy (mpg)", y: "cylinders"})
            
        Returns a new crosshair for the given data and options, drawing horizontal and vertical
        rules. The corresponding x and y values are also drawn just outside the bottom and left
        sides of the frame, respectively, typically on top of the axes. If either x or y is not
        specified, the crosshair will be one-dimensional.
        See more informations `here` <https://observablehq.com/plot/interactions/crosshair#crosshair>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.crosshair({arguments})")


    def crosshairX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.crosshairX(aapl, {x: "Date", y: "Close"})
            
        Like crosshair, but using pointerX when x is the dominant dimension, like time in a
        time-series chart.
        See more informations `here` <https://observablehq.com/plot/interactions/crosshair#crosshairX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.crosshairX({arguments})")


    def crosshairY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.crosshairY(aapl, {x: "Date", y: "Close"})
            
        Like crosshair, but using pointerY when y is the dominant dimension.
        See more informations `here` <https://observablehq.com/plot/interactions/crosshair#crosshairY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.crosshairY({arguments})")


    def delaunayLink(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.delaunayLink(penguins, {x: "culmen_depth_mm", y: "culmen_length_mm"})
            
        Draws links for each edge of the Delaunay triangulation of the points given by the x
        and y channels. Supports the same options as the link mark, except that x1, y1, x2, and
        y2 are derived automatically from x and y. When an aesthetic channel is specified (such
        as stroke or strokeWidth), the link inherits the corresponding channel value from one
        of its two endpoints arbitrarily.
        If a z channel is specified, the input points are grouped by z, and separate Delaunay
        triangulations are constructed for each group.
        See more informations `here` <https://observablehq.com/plot/marks/delaunay#delaunayLink>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.delaunayLink({arguments})")


    def delaunayMesh(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.delaunayMesh(penguins, {x: "culmen_depth_mm", y: "culmen_length_mm"})
            
        Draws a mesh of the Delaunay triangulation of the points given by the x and y channels.
        The stroke option defaults to currentColor, and the strokeOpacity defaults to 0.2. The
        fill option is not supported. When an aesthetic channel is specified (such as stroke or
        strokeWidth), the mesh inherits the corresponding channel value from one of its
        constituent points arbitrarily.
        If a z channel is specified, the input points are grouped by z, and separate Delaunay
        triangulations are constructed for each group.
        See more informations `here` <https://observablehq.com/plot/marks/delaunay#delaunayMesh>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.delaunayMesh({arguments})")


    def density(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.density(faithful, {x: "waiting", y: "eruptions"})
            
        Returns a new density mark for the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/density#density>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.density({arguments})")


    def differenceY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.differenceY(gistemp, {x: "Date", y: "Anomaly"})
            
        Returns a new difference with the given data and options. The mark is a composite of a
        positive area, negative area, and line. The positive area extends from the bottom of
        the frame to the line, and is clipped by the area extending from the comparison to the
        top of the frame. The negative area conversely extends from the top of the frame to the
        line, and is clipped by the area extending from the comparison to the bottom of the
        frame.
        See more informations `here` <https://observablehq.com/plot/marks/difference#differenceY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.differenceY({arguments})")


    def dodgeX(self, dodgeOptions=None, options=None):
        """
        .. code:: javascript
        
            Plot.dodgeX({y: "value"})
            
        Equivalent to Plot.dodgeY, but piling horizontally, creating a new x position channel
        that avoids overlapping. The y position channel is unchanged.
        See more informations `here` <https://observablehq.com/plot/transforms/dodge#dodgeX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (dodgeOptions, options))))
        return Plot_(f"{self.content}.dodgeX({arguments})")


    def dodgeY(self, dodgeOptions=None, options=None):
        """
        .. code:: javascript
        
            Plot.dodgeY({x: "date"})
            
        Given marks arranged along the x axis, the dodgeY transform piles them vertically by
        defining a y position channel that avoids overlapping. The x position channel is
        unchanged.
        See more informations `here` <https://observablehq.com/plot/transforms/dodge#dodgeY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (dodgeOptions, options))))
        return Plot_(f"{self.content}.dodgeY({arguments})")


    def dot(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.dot(sales, {x: "units", y: "fruit"})
            
        Returns a new dot with the given data and options. If neither the x nor y nor
        frameAnchor options are specified, data is assumed to be an array of pairs [[x₀, y₀],
        [x₁, y₁], [x₂, y₂], …] such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/dot#dot>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.dot({arguments})")


    def dotX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.dotX(cars.map((d) => d["economy (mpg)"]))
            
        Equivalent to dot except that if the x option is not specified, it defaults to the
        identity function and assumes that data = [x₀, x₁, x₂, …].
        If an interval is specified, such as d3.utcDay, y is transformed to (interval.floor(y)
        + interval.offset(interval.floor(y))) / 2. If the interval is specified as a number n,
        y will be the midpoint of two consecutive multiples of n that bracket y. Named UTC
        intervals such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/dot#dotX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.dotX({arguments})")


    def dotY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.dotY(cars.map((d) => d["economy (mpg)"]))
            
        Equivalent to dot except that if the y option is not specified, it defaults to the
        identity function and assumes that data = [y₀, y₁, y₂, …].
        If an interval is specified, such as d3.utcDay, x is transformed to (interval.floor(x)
        + interval.offset(interval.floor(x))) / 2. If the interval is specified as a number n,
        x will be the midpoint of two consecutive multiples of n that bracket x. Named UTC
        intervals such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/dot#dotY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.dotY({arguments})")


    def filter(self, test=None, options=None):
        """
        .. code:: javascript
        
            Plot.filter((d) => /[aeiouy]/i.test(d.letter), {x: "letter", y: "frequency"})
            
        Filters the data given the specified test. The test can be given as an accessor
        function (which receives the datum and index), or as a channel value definition such as
        a field name; truthy values are retained.
        See more informations `here` <https://observablehq.com/plot/transforms/filter#filter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (test, options))))
        return Plot_(f"{self.content}.filter({arguments})")


    def find(self, test=None):
        """
        .. code:: javascript
        
            Plot.groupX(
              {y1: Plot.find((d) => d.sex === "F"), y2: Plot.find((d) => d.sex === "M")},
              {x: "date", y: "value"}
            )
            
        Returns a reducer that finds the first datum for which the given test function returns
        a truthy value, and returns the corresponding channel value. This may be used with the
        group or bin transform to implement a “pivot wider” transform; for example, a “tall”
        dataset with separate rows for male and female observations may be transformed into a
        “wide” dataset with separate columns for male and female values.
        See more informations `here` <https://observablehq.com/plot/transforms/group#find>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (test,))))
        return Plot_(f"{self.content}.find({arguments})")


    def formatIsoDate(self, date=None):
        """
        .. code:: javascript
        
            Plot.formatIsoDate(new Date("2020-01-01T00:00:00.000Z")) // "2020-01-01"
            
        Given a date, returns the shortest equivalent ISO 8601 UTC string. If the given date is
        not valid, returns "Invalid Date". See isoformat.
        See more informations `here` <https://observablehq.com/plot/features/formats#formatIsoDate>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (date,))))
        return Plot_(f"{self.content}.formatIsoDate({arguments})")


    def formatMonth(self, locale=None, format=None):
        """
        .. code:: javascript
        
            Plot.textX(d3.range(12)).plot({x: {tickFormat: Plot.formatMonth(), ticks: 12}})
            
        .. code:: javascript
        
            Plot.formatMonth("es-MX", "long")(0) // "enero"
            
        Returns a function that formats a given month number (from 0 = January to 11 =
        December) according to the specified locale and format. The locale is a BCP 47 language
        tag and defaults to U.S. English. The format is a month format: either 2-digit,
        numeric, narrow, short, long; if not specified, it defaults to short.
        See more informations `here` <https://observablehq.com/plot/features/formats#formatMonth>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (locale, format))))
        return Plot_(f"{self.content}.formatMonth({arguments})")


    def formatWeekday(self, locale=None, format=None):
        """
        .. code:: javascript
        
            Plot.textX(d3.range(7)).plot({x: {tickFormat: Plot.formatWeekday()}})
            
        .. code:: javascript
        
            Plot.formatWeekday("es-MX", "long")(0) // "domingo"
            
        Returns a function that formats a given week day number (from 0 = Sunday to 6 =
        Saturday) according to the specified locale and format. The locale is a BCP 47 language
        tag and defaults to U.S. English. The format is a weekday format: either narrow, short,
        or long; if not specified, it defaults to short.
        See more informations `here` <https://observablehq.com/plot/features/formats#formatWeekday>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (locale, format))))
        return Plot_(f"{self.content}.formatWeekday({arguments})")


    def frame(self, options=None):
        """
        .. code:: javascript
        
            Plot.frame({stroke: "red"})
            
        Returns a new frame mark with the specified options.
        See more informations `here` <https://observablehq.com/plot/marks/frame#frame>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.frame({arguments})")


    def geo(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.geo(counties, {fill: (d) => d.properties.rate})
            
        Returns a new geo mark with the given data and options. If data is a GeoJSON feature
        collection, then the mark’s data is data.features; if data is a GeoJSON geometry
        collection, then the mark’s data is data.geometries; if data is some other GeoJSON
        object, then the mark’s data is the single-element array [data]. If the geometry option
        is not specified, data is assumed to be a GeoJSON object or an iterable of GeoJSON
        objects.
        See more informations `here` <https://observablehq.com/plot/marks/geo#geo>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.geo({arguments})")


    def geoCentroid(self, options=None):
        """
        .. code:: javascript
        
            Plot.geoCentroid({geometry: Plot.identity})
            
        The geoCentroid transform derives x and y channels representing the spherical centroids
        for the given GeoJSON geometry. If the geometry option is not specified, the mark’s
        data is assumed to be GeoJSON objects.
        See more informations `here` <https://observablehq.com/plot/transforms/centroid#geoCentroid>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.geoCentroid({arguments})")


    def graticule(self, options=None):
        """
        .. code:: javascript
        
            Plot.graticule()
            
        Returns a new geo mark with a 10° global graticule geometry object and the given
        options.
        See more informations `here` <https://observablehq.com/plot/marks/geo#graticule>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.graticule({arguments})")


    def gridFx(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.gridFx({strokeDasharray: "5,3"})
            
        Returns a new fx grid with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/grid#gridFx>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.gridFx({arguments})")


    def gridFy(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.gridFy({strokeDasharray: "5,3"})
            
        Returns a new fy grid with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/grid#gridFy>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.gridFy({arguments})")


    def gridX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.gridX({strokeDasharray: "5,3"})
            
        Returns a new x grid with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/grid#gridX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.gridX({arguments})")


    def gridY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.gridY({strokeDasharray: "5,3"})
            
        Returns a new y grid with the given options.
        See more informations `here` <https://observablehq.com/plot/marks/grid#gridY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.gridY({arguments})")


    def group(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.group({fill: "count"}, {x: "island", y: "species"})
            
        Groups on x, y, and the first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/group#group>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.group({arguments})")


    def groupX(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.groupX({y: "sum"}, {x: "species", y: "body_mass_g"})
            
        Groups on x and the first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/group#groupX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.groupX({arguments})")


    def groupY(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.groupY({x: "sum"}, {y: "species", x: "body_mass_g"})
            
        Groups on y and the first channel of z, fill, or stroke, if any.
        See more informations `here` <https://observablehq.com/plot/transforms/group#groupY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.groupY({arguments})")


    def groupZ(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.groupZ({x: "proportion"}, {fill: "species"})
            
        Groups on the first channel of z, fill, or stroke, if any. If none of z, fill, or
        stroke are channels, then all data (within each facet) is placed into a single group.
        See more informations `here` <https://observablehq.com/plot/transforms/group#groupZ>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.groupZ({arguments})")


    def hexagon(self, data=None, options=None):
        """
        Equivalent to dot except that the symbol option is set to hexagon.
        See more informations `here` <https://observablehq.com/plot/marks/dot#hexagon>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.hexagon({arguments})")


    def hexbin(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.dot(olympians, Plot.hexbin({fill: "count"}, {x: "weight", y: "height"}))
            
        Bins hexagonally on x and y. Also groups on the first channel of z, fill, or stroke, if
        any.
        See more informations `here` <https://observablehq.com/plot/transforms/hexbin#hexbin>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.hexbin({arguments})")


    def hexgrid(self, options=None):
        """
        .. code:: javascript
        
            Plot.hexgrid({stroke: "red"})
            
        Returns a new hexgrid mark with the specified options.
        See more informations `here` <https://observablehq.com/plot/marks/hexgrid#hexgrid>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.hexgrid({arguments})")


    def hull(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.hull(penguins, {x: "culmen_depth_mm", y: "culmen_length_mm"})
            
        Draws a convex hull around the points given by the x and y channels. The stroke option
        defaults to currentColor and the fill option defaults to none. When an aesthetic
        channel is specified (such as stroke or strokeWidth), the hull inherits the
        corresponding channel value from one of its constituent points arbitrarily.
        If a z channel is specified, the input points are grouped by z, and separate convex
        hulls are constructed for each group. If the z channel is not specified, it defaults to
        either the fill channel, if any, or the stroke channel, if any.
        See more informations `here` <https://observablehq.com/plot/marks/delaunay#hull>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.hull({arguments})")


    def identity(self, ):
        """
        .. code:: javascript
        
            Plot.contour(data, {width: w, height: h, fill: Plot.identity})
            
        This channel helper returns a source array as-is, avoiding an extra copy when defining
        a channel as being equal to the data.
        See more informations `here` <https://observablehq.com/plot/features/transforms#identity>`_.
        """
        return Plot_(f"{self.content}.identity()")


    def image(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.image(presidents, {x: "inauguration", y: "favorability", src: "portrait"})
            
        Returns a new image with the given data and options. If neither the x nor y nor
        frameAnchor options are specified, data is assumed to be an array of pairs [[x₀, y₀],
        [x₁, y₁], [x₂, y₂], …] such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/image#image>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.image({arguments})")


    def indexOf(self, ):
        """
        .. code:: javascript
        
            Plot.lineY(numbers, {x: Plot.indexOf, y: Plot.identity})
            
        This channel helper returns an array of numbers [0, 1, 2, 3, …]. It is used internally
        by marks with zero-based index defaults for channels.
        See more informations `here` <https://observablehq.com/plot/features/transforms#indexOf>`_.
        """
        return Plot_(f"{self.content}.indexOf()")


    def initializer(self, options=None, initializer=None):
        """
        This helper composes the initializer function with any other transforms present in the
        options, and returns a new options object. It is used internally by Plot’s built-in
        initializer transforms.
        See more informations `here` <https://observablehq.com/plot/features/transforms#initializer>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options, initializer))))
        return Plot_(f"{self.content}.initializer({arguments})")


    def interpolateNearest(self, index=None, width=None, height=None, x=None, y=None, value=None):
        """
        .. code:: javascript
        
            Plot.raster(ca55, {x: "LONGITUDE", y: "LATITUDE", fill: "MAG_IGRF90", interpolate: Plot.interpolateNearest})
            
        Assigns each pixel in the raster grid the value of the closest sample; effectively a
        Voronoi diagram.
        See more informations `here` <https://observablehq.com/plot/marks/raster#interpolateNearest>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (index, width, height, x, y, value))))
        return Plot_(f"{self.content}.interpolateNearest({arguments})")


    def interpolateNone(self, index=None, width=None, height=None, x=None, y=None, value=None):
        """
        .. code:: javascript
        
            Plot.raster(ca55, {x: "LONGITUDE", y: "LATITUDE", fill: "MAG_IGRF90", interpolate: Plot.interpolateNone})
            
        Applies a simple forward mapping of samples, binning them into pixels in the raster
        grid without any blending or interpolation. If multiple samples map to the same pixel,
        the last one wins; this can introduce bias if the points are not in random order, so
        use Plot.shuffle to randomize the input if needed.
        See more informations `here` <https://observablehq.com/plot/marks/raster#interpolateNone>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (index, width, height, x, y, value))))
        return Plot_(f"{self.content}.interpolateNone({arguments})")


    def interpolatorBarycentric(self, options=None):
        """
        .. code:: javascript
        
            Plot.raster(ca55, {x: "LONGITUDE", y: "LATITUDE", fill: "MAG_IGRF90", interpolate: Plot.interpolatorBarycentric()})
            
        Constructs a Delaunay triangulation of the samples, and then for each pixel in the
        raster grid, determines the triangle that covers the pixel’s centroid and interpolates
        the values associated with the triangle’s vertices using barycentric coordinates. If
        the interpolated values are ordinal or categorical (i.e., anything other than numbers
        or dates), then one of the three values will be picked randomly weighted by the
        barycentric coordinates; the given random number generator will be used, which defaults
        to a linear congruential generator with a fixed seed (for deterministic results).
        See more informations `here` <https://observablehq.com/plot/marks/raster#interpolatorBarycentric>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.interpolatorBarycentric({arguments})")


    def interpolatorRandomWalk(self, options=None):
        """
        .. code:: javascript
        
            Plot.raster(ca55, {x: "LONGITUDE", y: "LATITUDE", fill: "MAG_IGRF90", interpolate: Plot.interpolatorRandomWalk()})
            
        For each pixel in the raster grid, initiates a random walk, stopping when either the
        walk is within a given distance (minDistance) of a sample or the maximum allowable
        number of steps (maxSteps) have been taken, and then assigning the current pixel the
        closest sample’s value. The random walk uses the “walk on spheres” algorithm in two
        dimensions described by Sawhney and Crane, SIGGRAPH 2020; the given random number
        generator will be used, which defaults to a linear congruential generator with a fixed
        seed (for deterministic results).
        See more informations `here` <https://observablehq.com/plot/marks/raster#interpolatorRandomWalk>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.interpolatorRandomWalk({arguments})")


    def legend(self, options=None):
        """
        Renders a standalone legend for the scale defined by the given options object,
        returning a SVG or HTML figure element. This element can then be inserted into the page
        as described in the getting started guide. The options object must define at least one
        scale; see scale options for how to define a scale.
        For example, here is a ramp legend of a linear color scale with the default domain of
        [0, 1] and default scheme turbo:
        .. code:: javascript
        
            Plot.legend({color: {type: "linear"}})
            
        The options object may also include any additional legend options described in the
        previous section. For example, to make the above legend slightly wider:
        .. code:: javascript
        
            Plot.legend({width: 320, color: {type: "linear"}})
            
        See more informations `here` <https://observablehq.com/plot/features/legends#legend>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.legend({arguments})")


    def line(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.line(aapl, {x: "Date", y: "Close"})
            
        Returns a new line with the given data and options. If neither the x nor y options are
        specified, data is assumed to be an array of pairs [[x₀, y₀], [x₁, y₁], [x₂, y₂], …]
        such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/line#line>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.line({arguments})")


    def lineX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.lineX(aapl.map((d) => d.Close))
            
        Similar to line except that if the x option is not specified, it defaults to the
        identity function and assumes that data = [x₀, x₁, x₂, …]. If the y option is not
        specified, it defaults to [0, 1, 2, …].
        If the interval option is specified, the binY transform is implicitly applied to the
        specified options. The reducer of the output x channel may be specified via the reduce
        option, which defaults to first. To default to zero instead of showing gaps in data, as
        when the observed value represents a quantity, use the sum reducer.
        .. code:: javascript
        
            Plot.lineX(observations, {y: "date", x: "temperature", interval: "day"})
            
        The interval option is recommended to “regularize” sampled data; for example, if your
        data represents timestamped temperature measurements and you expect one sample per day,
        use "day" as the interval.
        See more informations `here` <https://observablehq.com/plot/marks/line#lineX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.lineX({arguments})")


    def lineY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.lineY(aapl.map((d) => d.Close))
            
        Similar to line except that if the y option is not specified, it defaults to the
        identity function and assumes that data = [y₀, y₁, y₂, …]. If the x option is not
        specified, it defaults to [0, 1, 2, …].
        If the interval option is specified, the binX transform is implicitly applied to the
        specified options. The reducer of the output y channel may be specified via the reduce
        option, which defaults to first. To default to zero instead of showing gaps in data, as
        when the observed value represents a quantity, use the sum reducer.
        .. code:: javascript
        
            Plot.lineY(observations, {x: "date", y: "temperature", interval: "day"})
            
        The interval option is recommended to “regularize” sampled data; for example, if your
        data represents timestamped temperature measurements and you expect one sample per day,
        use "day" as the interval.
        See more informations `here` <https://observablehq.com/plot/marks/line#lineY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.lineY({arguments})")


    def linearRegressionX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.linearRegressionX(mtcars, {y: "wt", x: "hp"})
            
        Returns a linear regression mark where x is the dependent variable and y is the
        independent variable. (This is the uncommon orientation.)
        See more informations `here` <https://observablehq.com/plot/marks/linear-regression#linearRegressionX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.linearRegressionX({arguments})")


    def linearRegressionY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.linearRegressionY(mtcars, {x: "wt", y: "hp"})
            
        Returns a linear regression mark where y is the dependent variable and x is the
        independent variable. (This is the common orientation.)
        See more informations `here` <https://observablehq.com/plot/marks/linear-regression#linearRegressionY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.linearRegressionY({arguments})")


    def link(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.link(inequality, {x1: "POP_1980", y1: "R90_10_1980", x2: "POP_2015", y2: "R90_10_2015"})
            
        Returns a new link with the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/link#link>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.link({arguments})")


    def map(self, outputs=None, options=None):
        """
        .. code:: javascript
        
            Plot.map({y: "cumsum"}, {y: d3.randomNormal()})
            
        Groups on the first channel of z, fill, or stroke, if any, and then for each channel
        declared in the specified outputs object, applies the corresponding map method. Each
        channel in outputs must have a corresponding input channel in options.
        See more informations `here` <https://observablehq.com/plot/transforms/map#map>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (outputs, options))))
        return Plot_(f"{self.content}.map({arguments})")


    def mapX(self, map=None, options=None):
        """
        .. code:: javascript
        
            Plot.mapX("cumsum", {x: d3.randomNormal()})
            
        Equivalent to Plot.map({x: map, x1: map, x2: map}, options), but ignores any of x, x1,
        and x2 not present in options. In addition, if none of x, x1, or x2 are specified, then
        x defaults to identity.
        See more informations `here` <https://observablehq.com/plot/transforms/map#mapX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (map, options))))
        return Plot_(f"{self.content}.mapX({arguments})")


    def mapY(self, map=None, options=None):
        """
        .. code:: javascript
        
            Plot.mapY("cumsum", {y: d3.randomNormal()})
            
        Equivalent to Plot.map({y: map, y1: map, y2: map}, options), but ignores any of y, y1,
        and y2 not present in options. In addition, if none of y, y1, or y2 are specified, then
        y defaults to identity.
        See more informations `here` <https://observablehq.com/plot/transforms/map#mapY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (map, options))))
        return Plot_(f"{self.content}.mapY({arguments})")


    def marks(self, *marks):
        """
        .. code:: javascript
        
            Plot.marks(
              Plot.ruleY([0]),
              Plot.areaY(data, {fill: color, fillOpacity, ...options}),
              Plot.lineY(data, {stroke: color, ...options})
            )
            
        A convenience method for composing a mark from a series of other marks. Returns an
        array of marks that implements the mark.plot function. See the box mark implementation
        for an example.
        See more informations `here` <https://observablehq.com/plot/features/marks#marks>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (marks,))))
        return Plot_(f"{self.content}.marks({arguments})")


    def normalize(self, basis=None):
        """
        .. code:: javascript
        
            Plot.map({y: Plot.normalize("first")}, {x: "Date", y: "Close", stroke: "Symbol"})
            
        Returns a normalize map method for the given basis, suitable for use with the map
        transform.
        See more informations `here` <https://observablehq.com/plot/transforms/normalize#normalize>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (basis,))))
        return Plot_(f"{self.content}.normalize({arguments})")


    def normalizeX(self, basis=None, options=None):
        """
        .. code:: javascript
        
            Plot.normalizeX("first", {y: "Date", x: "Close", stroke: "Symbol"})
            
        Like mapX, but applies the normalize map method with the given basis. The basis option
        can also be mixed into the specified options like so:
        .. code:: javascript
        
            Plot.normalizeX({basis: "first", y: "Date", x: "Close", stroke: "Symbol"})
            
        If not specified, the basis defaults to first.
        See more informations `here` <https://observablehq.com/plot/transforms/normalize#normalizeX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (basis, options))))
        return Plot_(f"{self.content}.normalizeX({arguments})")


    def normalizeY(self, basis=None, options=None):
        """
        .. code:: javascript
        
            Plot.normalizeY("first", {x: "Date", y: "Close", stroke: "Symbol"})
            
        Like mapY, but applies the normalize map method with the given basis. The basis option
        can also be mixed into the specified options like so:
        .. code:: javascript
        
            Plot.normalizeY({basis: "first", x: "Date", y: "Close", stroke: "Symbol"})
            
        If not specified, the basis defaults to first.
        See more informations `here` <https://observablehq.com/plot/transforms/normalize#normalizeY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (basis, options))))
        return Plot_(f"{self.content}.normalizeY({arguments})")


    def plot(self, options=None):
        """
        .. code:: javascript
        
            Plot.plot({
              height: 200,
              marks: [
                Plot.barY(alphabet, {x: "letter", y: "frequency"})
              ]
            })
            
        Renders a new plot with the specified options, returning a SVG or HTML figure element.
        This element can then be inserted into the page as described in the getting started
        guide.
        See more informations `here` <https://observablehq.com/plot/features/plots#plot>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.plot({arguments})")


    def pointer(self, options=None):
        """
        .. code:: javascript
        
            Plot.tip(penguins, Plot.pointer({x: "culmen_length_mm", y: "culmen_depth_mm"}))
            
        Applies the pointer render transform to the specified options to filter the mark index
        such that only the point closest to the pointer is rendered; the mark will re-render
        interactively in response to pointer events.
        See more informations `here` <https://observablehq.com/plot/interactions/pointer#pointer>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.pointer({arguments})")


    def pointerX(self, options=None):
        """
        .. code:: javascript
        
            Plot.tip(aapl, Plot.pointerX({x: "Date", y: "Close"}))
            
        Like pointer, except the determination of the closest point considers mostly the x
        (horizontal↔︎) position; this should be used for plots where x is the dominant
        dimension, such as time in a time-series chart, the binned quantitative dimension in a
        histogram, or the categorical dimension of a bar chart.
        See more informations `here` <https://observablehq.com/plot/interactions/pointer#pointerX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.pointerX({arguments})")


    def pointerY(self, options=None):
        """
        .. code:: javascript
        
            Plot.tip(alphabet, Plot.pointerY({x: "frequency", y: "letter"}))
            
        Like pointer, except the determination of the closest point considers mostly the y
        (vertical↕︎) position; this should be used for plots where y is the dominant dimension,
        such as time in a time-series chart, the binned quantitative dimension in a histogram,
        or the categorical dimension of a bar chart.
        See more informations `here` <https://observablehq.com/plot/interactions/pointer#pointerY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.pointerY({arguments})")


    def raster(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.raster(volcano.values, {width: volcano.width, height: volcano.height})
            
        Returns a new raster mark with the given (optional) data and options.
        See more informations `here` <https://observablehq.com/plot/marks/raster#raster>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.raster({arguments})")


    def rect(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.rect(olympians, Plot.bin({fill: "count"}, {x: "weight", y: "height"}))
            
        Returns a new rect with the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/rect#rect>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.rect({arguments})")


    def rectX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.rectX(olympians, Plot.binY({x: "count"}, {y: "weight"}))
            
        Equivalent to rect, except that if neither the x1 nor x2 option is specified, the x
        option may be specified as shorthand to apply an implicit stackX transform; this is the
        typical configuration for a histogram with horizontal→ rects aligned at x = 0. If the x
        option is not specified, it defaults to the identity function.
        See more informations `here` <https://observablehq.com/plot/marks/rect#rectX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.rectX({arguments})")


    def rectY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight"}))
            
        Equivalent to rect, except that if neither the y1 nor y2 option is specified, the y
        option may be specified as shorthand to apply an implicit stackY transform; this is the
        typical configuration for a histogram with vertical↑ rects aligned at y = 0. If the y
        option is not specified, it defaults to the identity function.
        See more informations `here` <https://observablehq.com/plot/marks/rect#rectY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.rectY({arguments})")


    def reverse(self, options=None):
        """
        .. code:: javascript
        
            Plot.reverse({x: "culmen_length_mm", y: "culmen_depth_mm"})
            
        Reverses the order of the data.
        See more informations `here` <https://observablehq.com/plot/transforms/sort#reverse>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.reverse({arguments})")


    def ruleX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.ruleX([0]) // as annotation
            
        .. code:: javascript
        
            Plot.ruleX(alphabet, {x: "letter", y: "frequency"}) // like barY
            
        Returns a new vertical↕︎ rule with the given data and options. The following channels
        are optional:
        If x is not specified, it defaults to identity and assumes that data = [x₀, x₁, x₂, …].
        If x is null, the rule will be centered horizontally in the plot frame.
        If y is specified, it is shorthand for y2 with y1 equal to zero; this is the typical
        configuration for a vertical lollipop chart with rules aligned at y = 0. If y1 is not
        specified, the rule will start at the top of the plot (or facet). If y2 is not
        specified, the rule will end at the bottom of the plot (or facet).
        If an interval is specified, such as d3.utcDay, y1 and y2 can be derived from y:
        interval.floor(y) is invoked for each y to produce y1, and interval.offset(y1) is
        invoked for each y1 to produce y2. If the interval is specified as a number n, y1 and
        y2 are taken as the two consecutive multiples of n that bracket y. Named UTC intervals
        such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/rule#ruleX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.ruleX({arguments})")


    def ruleY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.ruleY([0]) // as annotation
            
        .. code:: javascript
        
            Plot.ruleY(alphabet, {y: "letter", x: "frequency"}) // like barX
            
        Returns a new horizontal↔︎ rule with the given data and options. The following channels
        are optional:
        If y is not specified, it defaults to identity and assumes that data = [y₀, y₁, y₂, …].
        If y is null, the rule will be centered vertically in the plot frame.
        If x is specified, it is shorthand for x2 with x1 equal to zero; this is the typical
        configuration for a horizontal lollipop chart with rules aligned at x = 0. If x1 is not
        specified, the rule will start at the left edge of the plot (or facet). If x2 is not
        specified, the rule will end at the right edge of the plot (or facet).
        If an interval is specified, such as d3.utcDay, x1 and x2 can be derived from x:
        interval.floor(x) is invoked for each x to produce x1, and interval.offset(x1) is
        invoked for each x1 to produce x2. If the interval is specified as a number n, x1 and
        x2 are taken as the two consecutive multiples of n that bracket x. Named UTC intervals
        such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/rule#ruleY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.ruleY({arguments})")


    def scale(self, options=None):
        """
        You can also create a standalone scale with Plot.scale(options). The options object
        must define at least one scale; see Scale options for how to define a scale. For
        example, here is a categorical color scale with the Tableau10 color scheme and a domain
        of fruits:
        .. code:: javascript
        
            const color = Plot.scale({color: {scheme: "Tableau10", domain: ["apple", "orange", "pear"]}});
            
        Both plot.scale and Plot.scale return scale objects. These objects represent the actual
        (or “materialized”) scale options used by Plot, including the domain, range,
        interpolate function, etc. The scale’s label, if any, is also returned; however, note
        that other axis properties are not currently exposed. Point and band scales also expose
        their materialized bandwidth and step.
        .. code:: javascript
        
            color.domain // ["apple", "orange", "pear"]
            
        For convenience, scale objects expose a scale.apply(input) method which returns the
        scale’s output for the given input value. When applicable, scale objects also expose a
        scale.invert(output) method which returns the corresponding input value from the
        scale’s domain for the given output value.
        .. code:: javascript
        
            color.apply("apple") // "#4e79a7"
            
        To apply a standalone scale object to a plot, pass it to Plot.plot as the corresponding
        scale options, such as color:
        .. code:: javascript
        
            Plot.cellX(["apple", "apple", "orange", "pear", "orange"]).plot({color})
            
        As another example, below are two plots with different options where the second plot
        uses the color scale from the first plot:
        .. code:: javascript
        
            const plot1 = Plot.plot({...options1});
            const plot2 = Plot.plot({...options2, color: plot1.scale("color")});
            
        See more informations `here` <https://observablehq.com/plot/features/scales#scale>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.scale({arguments})")


    def select(self, selector=None, options=None):
        """
        .. code:: javascript
        
            Plot.select("first", {x: "Date", y: "Close"}) // selectFirst
            
        .. code:: javascript
        
            Plot.select({y: "min"}, {x: "Date", y: "Close"}) // selectMinY
            
        Selects the points in each series determined by the given selector, which is one of:
        In the last case, name is the name of a channel and value is a value selector, which is
        one of:
        For example, to select the point in each city with the highest temperature
        (“selectMaxFill”):
        .. code:: javascript
        
            Plot.select({fill: "max"}, {x: "date", y: "city", z: "city", fill: "temperature"})
            
        A selector function must return the selected index: a subset of the passed-in series
        index. For example, selectFirst and selectMinY can be implemented using functions like
        so:
        .. code:: javascript
        
            Plot.select((I) => [I[0]], {x: "Date", y: "Close"}) // selectFirst
            
        .. code:: javascript
        
            Plot.select({y: (I, Y) => [d3.least(I, (i) => Y[i])]}, {x: "Date", y: "Close"}) // selectMinY
            
        Or, to select the point within each series that is the closest to the median of y:
        .. code:: javascript
        
            Plot.select({y: selectorMedian}, {x: "year", y: "revenue", fill: "format"})
            
        .. code:: javascript
        
            function selectorMedian(I, V) {
              const median = d3.median(I, (i) => V[i]);
              const i = d3.least(I, (i) => Math.abs(V[i] - median));
              return [i];
            }
            
        The following selects a sample of 10% of the data:
        .. code:: javascript
        
            Plot.select({y: selectorSample}, {x: "Date", y: "Close"})
            
        .. code:: javascript
        
            function selectorSample(I) {
              return I.filter((i, j) => j % 10 === 0);
            }
            
        See more informations `here` <https://observablehq.com/plot/transforms/select#select>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector, options))))
        return Plot_(f"{self.content}.select({arguments})")


    def selectFirst(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectFirst({x: "Date", y: "Close"})
            
        Selects the first point of each series according to input order.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectFirst>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectFirst({arguments})")


    def selectLast(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectLast({x: "Date", y: "Close"})
            
        Selects the last point of each series according to input order.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectLast>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectLast({arguments})")


    def selectMaxX(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectMaxX({x: "Date", y: "Close"})
            
        Selects the rightmost point of each series.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectMaxX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectMaxX({arguments})")


    def selectMaxY(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectMaxY({x: "Date", y: "Close"})
            
        Selects the highest point of each series.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectMaxY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectMaxY({arguments})")


    def selectMinX(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectMinX({x: "Date", y: "Close"})
            
        Selects the leftmost point of each series.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectMinX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectMinX({arguments})")


    def selectMinY(self, options=None):
        """
        .. code:: javascript
        
            Plot.selectMinY({x: "Date", y: "Close"})
            
        Selects the lowest point of each series.
        See more informations `here` <https://observablehq.com/plot/transforms/select#selectMinY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.selectMinY({arguments})")


    def shiftX(self, interval=None, options=None):
        """
        .. code:: javascript
        
            Plot.shiftX("7 days", {x: "Date", y: "Close"})
            
        Derives an x1 channel from the input x channel by shifting values by the given
        interval. The interval may be specified as: a name (second, minute, hour, day, week,
        month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday,
        sunday) with an optional number and sign (e.g., +3 days or -1 year); or as a number; or
        as an implementation — such as d3.utcMonth — with interval.floor(value),
        interval.offset(value), and interval.range(start, stop) methods.
        The shiftX also transform aliases the x channel to x2 and applies a domain hint to the
        x2 channel such that by default the plot shows only the intersection of x1 and x2. For
        example, if the interval is +1 year, the first year of the data is not shown.
        See more informations `here` <https://observablehq.com/plot/transforms/shift#shiftX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (interval, options))))
        return Plot_(f"{self.content}.shiftX({arguments})")


    def shuffle(self, options=None):
        """
        .. code:: javascript
        
            Plot.shuffle({x: "culmen_length_mm", y: "culmen_depth_mm"})
            
        Shuffles the data randomly. If a seed option is specified, a linear congruential
        generator with the given seed is used to generate random numbers; otherwise,
        Math.random is used.
        See more informations `here` <https://observablehq.com/plot/transforms/sort#shuffle>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.shuffle({arguments})")


    def sort(self, order=None, options=None):
        """
        .. code:: javascript
        
            Plot.sort("body_mass_g", {x: "culmen_length_mm", y: "culmen_depth_mm"})
            
        Sorts the data by the specified order, which is one of:
        In the object case, the channel option specifies the name of the channel, while the
        order option specifies ascending (the default) or descending order. You can also use
        the shorthand -name ^0.6.7 to sort by descending order of the channel with the given
        name. For example, sort: {channel: "-r"} will sort by descending radius (r).
        In the function case, if the sort function does not take exactly one argument, it is
        interpreted as a comparator function; otherwise it is interpreted as an accessor
        function.
        See more informations `here` <https://observablehq.com/plot/transforms/sort#sort>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (order, options))))
        return Plot_(f"{self.content}.sort({arguments})")


    def sphere(self, options=None):
        """
        .. code:: javascript
        
            Plot.sphere()
            
        Returns a new geo mark with a Sphere geometry object and the given options.
        See more informations `here` <https://observablehq.com/plot/marks/geo#sphere>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.sphere({arguments})")


    def spike(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.spike(counties, Plot.geoCentroid({length: (d) => d.properties.population}))
            
        Equivalent to vector except that the shape defaults to spike, the stroke defaults to
        currentColor, the strokeWidth defaults to 1, the fill defaults to stroke, the
        fillOpacity defaults to 0.3, and the anchor defaults to start.
        See more informations `here` <https://observablehq.com/plot/marks/vector#spike>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.spike({arguments})")


    def stackX(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackX({y: "year", x: "revenue", z: "format", fill: "group"})
            
        Like stackY, but with x as the input value channel, y as the stack index, x1, x2 and x
        as the output channels.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackX({arguments})")


    def stackX1(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackX1({y: "year", x: "revenue", z: "format", fill: "group"})
            
        Like stackX, except that the x1 channel is returned as the x channel. This can be used,
        for example, to draw a line at the left edge of each stacked area.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackX1>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackX1({arguments})")


    def stackX2(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackX2({y: "year", x: "revenue", z: "format", fill: "group"})
            
        Like stackX, except that the x2 channel is returned as the x channel. This can be used,
        for example, to draw a line at the right edge of each stacked area.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackX2>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackX2({arguments})")


    def stackY(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackY({x: "year", y: "revenue", z: "format", fill: "group"})
            
        Creates new channels y1 and y2, obtained by stacking the original y channel for data
        points that share a common x (and possibly z) value. A new y channel is also returned,
        which lazily computes the middle value of y1 and y2. The input y channel defaults to a
        constant 1, resulting in a count of the data points. The stack options (offset, order,
        and reverse) may be specified as part of the options object, if the only argument, or
        as a separate stack options argument.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackY({arguments})")


    def stackY1(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackY1({x: "year", y: "revenue", z: "format", fill: "group"})
            
        Like stackY, except that the y1 channel is returned as the y channel. This can be used,
        for example, to draw a line at the bottom of each stacked area.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackY1>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackY1({arguments})")


    def stackY2(self, stack=None, options=None):
        """
        .. code:: javascript
        
            Plot.stackY2({x: "year", y: "revenue", z: "format", fill: "group"})
            
        Like stackY, except that the y2 channel is returned as the y channel. This can be used,
        for example, to draw a line at the top of each stacked area.
        See more informations `here` <https://observablehq.com/plot/transforms/stack#stackY2>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stack, options))))
        return Plot_(f"{self.content}.stackY2({arguments})")


    def text(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.text(driving, {x: "miles", y: "gas", text: "year"})
            
        Returns a new text mark with the given data and options. If neither the x nor y nor
        frameAnchor options are specified, data is assumed to be an array of pairs [[x₀, y₀],
        [x₁, y₁], [x₂, y₂], …] such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/text#text>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.text({arguments})")


    def textX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.textX(alphabet.map((d) => d.frequency))
            
        Equivalent to text, except x defaults to identity and assumes that data = [x₀, x₁, x₂,
        …].
        If an interval is specified, such as d3.utcDay, y is transformed to (interval.floor(y)
        + interval.offset(interval.floor(y))) / 2. If the interval is specified as a number n,
        y will be the midpoint of two consecutive multiples of n that bracket y. Named UTC
        intervals such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/text#textX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.textX({arguments})")


    def textY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.textY(alphabet.map((d) => d.frequency))
            
        Equivalent to text, except y defaults to identity and assumes that data = [y₀, y₁, y₂,
        …].
        If an interval is specified, such as d3.utcDay, x is transformed to (interval.floor(x)
        + interval.offset(interval.floor(x))) / 2. If the interval is specified as a number n,
        x will be the midpoint of two consecutive multiples of n that bracket x. Named UTC
        intervals such as day are also supported; see scale options.
        See more informations `here` <https://observablehq.com/plot/marks/text#textY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.textY({arguments})")


    def tickX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.tickX(stateage, {x: "population", y: "age"})
            
        Returns a new vertical↕︎ tick with the given data and options. The following channels
        are required:
        The following optional channels are supported:
        If the y channel is not specified, the tick will span the full vertical extent of the
        frame.
        See more informations `here` <https://observablehq.com/plot/marks/tick#tickX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.tickX({arguments})")


    def tickY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.tickY(stateage, {y: "population", x: "age"})
            
        Returns a new horizontal↔︎ tick with the given data and options. The following channels
        are required:
        The following optional channels are supported:
        If the x channel is not specified, the tick will span the full vertical extent of the
        frame.
        See more informations `here` <https://observablehq.com/plot/marks/tick#tickY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.tickY({arguments})")


    def tip(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.tip(aapl, {x: "Date", y: "Close"})
            
        Returns a new tip mark with the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/tip#tip>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.tip({arguments})")


    def transform(self, options=None, transform=None):
        """
        .. code:: javascript
        
            Plot.transform(options, (data, facets) => {
              return {
                data,
                facets: facets.map((I) => I.filter(() => Math.random() > 0.5))
              };
            })
            
        Given an options object that may specify some basic transforms (filter, sort, or
        reverse) or a custom transform function, composes those transforms if any with the
        given transform function, returning a new options object. If a custom transform
        function is present on the given options, any basic transforms are ignored. Any
        additional input options are passed through in the returned options object. This method
        facilitates applying the basic transforms prior to applying the given custom transform
        and is used internally by Plot’s built-in transforms.
        See more informations `here` <https://observablehq.com/plot/features/transforms#transform>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options, transform))))
        return Plot_(f"{self.content}.transform({arguments})")


    def tree(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.tree(flare, {path: "name", delimiter: "."})
            
        Returns a new tree mark with the given data and options.
        See more informations `here` <https://observablehq.com/plot/marks/tree#tree>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.tree({arguments})")


    def treeLink(self, options=None):
        """
        Populates x1, y1, x2, and y2 with the positions for each link in the tree, where x1 &
        y1 represents the position of the parent node and x2 & y2 the position of the child
        node. The default curve is bump-x, the default stroke is #555, the default strokeWidth
        is 1.5, and the default strokeOpacity is 0.5. This transform is often used with the
        link or arrow mark.
        The treeLink transform will likewise derive output columns for any options that have
        one of the following named link values:
        In addition, if any option value is specified as an object with a node method, a
        derived output column will be generated by invoking the node method for each child node
        in the tree; likewise if any option value is specified as an object with a link method,
        a derived output column will be generated by invoking the link method for each link in
        the tree, being passed two node arguments, the child and the parent.
        See more informations `here` <https://observablehq.com/plot/transforms/tree#treeLink>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.treeLink({arguments})")


    def treeNode(self, options=None):
        """
        Populates x and y with the positions for each node in the tree. The default frameAnchor
        inherits the treeAnchor. This transform is often used with the dot or text mark.
        The treeNode transform will derive output columns for any options that have one of the
        following named node values:
        In addition, if any option value is specified as an object with a node method, a
        derived output column will be generated by invoking the node method for each node in
        the tree.
        See more informations `here` <https://observablehq.com/plot/transforms/tree#treeNode>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (options,))))
        return Plot_(f"{self.content}.treeNode({arguments})")


    def valueof(self, data=None, value=None, type=None):
        """
        .. code:: javascript
        
            Plot.valueof(aapl, "Close")
            
        Given an iterable data and some value accessor, returns an array (a column) of the
        specified type with the corresponding value of each element of the data. The value
        accessor may be one of the following types:
        If type is specified, it must be Array or a similar class that implements the
        Array.from interface such as a typed array. When type is Array or a typed array class,
        the return value of valueof will be an instance of the same (or null or undefined).
        When type is a typed array, values will be implicitly coerced numbers, and if type is
        Float64Array, Float32Array, or a subclass of the same, null values will be implicitly
        replaced with NaN. If type is not specified, valueof may return either an array or a
        typed array (or null or undefined).
        valueof is not guaranteed to return a new array. When a transform method is used, or
        when the given value is an array that is compatible with the requested type, the array
        may be returned as-is without making a copy.
        See more informations `here` <https://observablehq.com/plot/features/transforms#valueof>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, value, type))))
        return Plot_(f"{self.content}.valueof({arguments})")


    def vector(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.vector(wind, {x: "longitude", y: "latitude", length: "speed", rotate: "direction"})
            
        Returns a new vector with the given data and options. If neither the x nor y options
        are specified, data is assumed to be an array of pairs [[x₀, y₀], [x₁, y₁], [x₂, y₂],
        …] such that x = [x₀, x₁, x₂, …] and y = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/vector#vector>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.vector({arguments})")


    def vectorX(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.vectorX(cars.map((d) => d["economy (mpg)"]))
            
        Equivalent to vector except that if the x option is not specified, it defaults to the
        identity function and assumes that data = [x₀, x₁, x₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/vector#vectorX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.vectorX({arguments})")


    def vectorY(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.vectorY(cars.map((d) => d["economy (mpg)"]))
            
        Equivalent to vector except that if the y option is not specified, it defaults to the
        identity function and assumes that data = [y₀, y₁, y₂, …].
        See more informations `here` <https://observablehq.com/plot/marks/vector#vectorY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.vectorY({arguments})")


    def voronoi(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.voronoi(penguins, {x: "culmen_depth_mm", y: "culmen_length_mm"})
            
        Draws polygons for each cell of the Voronoi tessellation of the points given by the x
        and y channels.
        If a z channel is specified, the input points are grouped by z, and separate Voronoi
        tessellations are constructed for each group.
        See more informations `here` <https://observablehq.com/plot/marks/delaunay#voronoi>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.voronoi({arguments})")


    def voronoiMesh(self, data=None, options=None):
        """
        .. code:: javascript
        
            Plot.voronoiMesh(penguins, {x: "culmen_depth_mm", y: "culmen_length_mm"})
            
        Draws a mesh for the cell boundaries of the Voronoi tessellation of the points given by
        the x and y channels. The stroke option defaults to currentColor, and the strokeOpacity
        defaults to 0.2. The fill option is not supported. When an aesthetic channel is
        specified (such as stroke or strokeWidth), the mesh inherits the corresponding channel
        value from one of its constituent points arbitrarily.
        If a z channel is specified, the input points are grouped by z, and separate Voronoi
        tessellations are constructed for each group.
        See more informations `here` <https://observablehq.com/plot/marks/delaunay#voronoiMesh>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, options))))
        return Plot_(f"{self.content}.voronoiMesh({arguments})")


    def window(self, k=None):
        """
        .. code:: javascript
        
            Plot.map({y: Plot.window(24)}, {x: "Date", y: "Close", stroke: "Symbol"})
            
        Returns a window map method for the given window size k, suitable for use with
        Plot.map. For additional options to the window transform, replace the number k with an
        object with properties k, anchor, reduce, or strict.
        See more informations `here` <https://observablehq.com/plot/transforms/window#window>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (k,))))
        return Plot_(f"{self.content}.window({arguments})")


    def windowX(self, k=None, options=None):
        """
        .. code:: javascript
        
            Plot.windowX(24, {y: "Date", x: "Anomaly"})
            
        Like mapX, but applies the window map method with the given window size k. For
        additional options to the window transform, replace the number k with an object with
        properties k, anchor, or reduce.
        See more informations `here` <https://observablehq.com/plot/transforms/window#windowX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (k, options))))
        return Plot_(f"{self.content}.windowX({arguments})")


    def windowY(self, k=None, options=None):
        """
        .. code:: javascript
        
            Plot.windowY(24, {x: "Date", y: "Anomaly"})
            
        Like mapY, but applies the window map method with the given window size k. For
        additional options to the window transform, replace the number k with an object with
        properties k, anchor, or reduce.
        See more informations `here` <https://observablehq.com/plot/transforms/window#windowY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (k, options))))
        return Plot_(f"{self.content}.windowY({arguments})")


Plot = Plot_()