  <script>
      const xmlns = "http://www.w2.org/2000/xmlns/";
      const xlinkns = "http://www.w3.org/1999/xlink";
      const svgns = "http://www.w3.org/2000/svg";
      var mysvg;

      function waitForFigure(selector) {
        return new Promise(resolve => {
            if (document.getElementById(selector).childNodes[0]) {
                return resolve(document.getElementById(selector).childNodes[0]);
            }
      
            const observer = new MutationObserver(mutations => {
                if (document.getElementById(selector).childNodes[0]) {
                    observer.disconnect();
                    resolve(document.getElementById(selector).childNodes[0]);
                }
            });
      
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });
      }

      // Depending of the generated figure, sometimes the SVG content
      // is not at the root but on the first level of childs.
      function getSVG(figure) {
        if (figure.tagName === "svg"){
          return figure;
        } else {
          return Array.from(figure.childNodes).filter(e => e.tagName === "svg")[0];
        }
      }

      function serialize(svg) {
        const fragment = window.location.href + "#";
        const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);
        while (walker.nextNode()) {
          for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
              attr.value = attr.value.replace(fragment, "#");
            }
          }
        }
        // svg.setAttributeNS(xmlns, "xmlns", svgns);
        // svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);
        const serializer = new window.XMLSerializer;
        const string = serializer.serializeToString(svg);
        // return new Blob([string], {type: "image/svg+xml"});
        return string;
      };

      function int(string){
        return parseInt(string, 10);
      }

      function getAttributeNames(svg){
        return svg.getAttributeNames()
                  .filter(name => !(["viewBox", "class", "width", "height"].includes(name)));
      }
      
      function gFromSVG(svg, lastHeight){
        const boundingRect = svg.getBoundingClientRect();
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        for (name of getAttributeNames(svg)){g.setAttribute(name, svg.getAttribute(name));}
        g.setAttribute("transform", `translate(0, ${lastHeight})`)
        g.append(...svg.childNodes);
        return g;
      }

      function gSVGFromSpan(svg){
        const style = window.getComputedStyle(svg);
        const dx = int(style.marginLeft) - int(style.marginRight);
        const dy = int(style.marginTop) - int(style.marginBottom);
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        for (name of getAttributeNames(svg)){g.setAttribute(name, svg.getAttribute(name));}
        g.setAttribute("transform", `translate(${dx}, ${dy})`)
        g.append(...svg.childNodes);
        return g
      }

      function textFromSpan(string, x){
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("transform", `translate(${x}, 0)`)
        text.setAttribute("y", "0.32em");
        text.append(string);
        return text;
      }

      function gFromSpan(span, spanCount){
        const svg = span.childNodes[0];
        const text = span.childNodes[1];
        const svgBoundingRect = svg.getBoundingClientRect();
        const textBoundingRect = span.getBoundingClientRect();
        const xText = textBoundingRect.width - svgBoundingRect.width;

        var style = window.getComputedStyle(span);
        var dx = int(style.marginLeft) - int(style.marginRight);

        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const x = textBoundingRect.x - textBoundingRect.width - dx * spanCount;
        const y = textBoundingRect.height;
        g.setAttribute("transform", `translate(${x}, ${y})`)
        g.append(gSVGFromSpan(svg));
        g.append(textFromSpan(text, xText))
        return g;
      }

      function gFromObj(obj){
        const boundingRect = obj.getBoundingClientRect();
        var childNodes = [];
        var spanCount = 0;
        for (child of obj.childNodes){
          var tmpHeight = child.getBoundingClientRect().height;
          switch(child.tagName){
            case "SPAN":
              childNodes.push(gFromSpan(child, spanCount));
              spanCount += 1;
              break;
            case "svg":
              childNodes.push(gFromSVG(child, lastHeight));
              break;
            case "STYLE":
              break;
            default:
              childNodes.push(...gFromObj(child));
          }
          var lastHeight = tmpHeight;
        }
        return childNodes;
      }

      waitForFigure("myplot").then(figure => {
        const div = document.getElementById("myplot");
        const svg = figure.childNodes[1];
        const width = svg.getBoundingClientRect().width;
        const height = figure.getBoundingClientRect().height;
        
        const g = gFromObj(div);
        const new_svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        for (name of getAttributeNames(svg)){new_svg.setAttribute(name, svg.getAttribute(name));}
        new_svg.setAttribute("width", `${width}`);
        new_svg.setAttribute("height", `${height}`);
        new_svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        new_svg.append(...g);
        div.remove(...div.childNodes)
        document.body.appendChild(new_svg);
        mysvg = serialize(new_svg);
      })
    </script>
