  <script>
      const xmlns = "http://www.w2.org/2000/xmlns/";
      const xlinkns = "http://www.w3.org/1999/xlink";
      const svgns = "http://www.w3.org/2000/svg";
      var mysvg;

      function waitForFigure(selector) {
        return new Promise(resolve => {
            if (document.getElementById(selector).childNodes[0]) {
                return resolve(document.getElementById(selector).childNodes[0]);
            }
      
            const observer = new MutationObserver(mutations => {
                if (document.getElementById(selector).childNodes[0]) {
                    observer.disconnect();
                    resolve(document.getElementById(selector).childNodes[0]);
                }
            });
      
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });
      }

      // Depending of the generated figure, sometimes the SVG content
      // is not at the root but on the first level of childs.
      function getSVG(figure) {
        if (figure.tagName === "svg"){
          return figure;
        } else {
          return Array.from(figure.childNodes).filter(e => e.tagName === "svg")[0];
        }
      }

      function serialize(svg) {
        const fragment = window.location.href + "#";
        const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);
        while (walker.nextNode()) {
          for (const attr of walker.currentNode.attributes) {
            if (attr.value.includes(fragment)) {
              attr.value = attr.value.replace(fragment, "#");
            }
          }
        }
        // svg.setAttributeNS(xmlns, "xmlns", svgns);
        // svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);
        const serializer = new window.XMLSerializer;
        const string = serializer.serializeToString(svg);
        // return new Blob([string], {type: "image/svg+xml"});
        return string;
      };

      function int(string){
        return parseInt(string, 10);
      }

      function divmod(x, y){
        return Math.floor(y, x), y % x;
      }

      function getAttributeNames(svg){
        return svg.getAttributeNames()
                  .filter(name => !(["viewBox", "class", "width", "height", "stroke", "fill"].includes(name)));
      }
      
      function gFromSVG(svg, lastHeight){
        const boundingRect = svg.getBoundingClientRect();
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        for (const name of getAttributeNames(svg)){g.setAttribute(name, svg.getAttribute(name));}
        g.setAttribute("transform", `translate(0, ${lastHeight})`)
        g.append(...svg.childNodes);
        return g;
      }

      function gSVGFromSpan(svg){
        const style = window.getComputedStyle(svg);
        const dx = int(style.marginLeft) - int(style.marginRight);
        const dy = int(style.marginTop) - int(style.marginBottom);
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        for (const name of getAttributeNames(svg)){g.setAttribute(name, svg.getAttribute(name));}
        g.setAttribute("transform", `translate(${dx}, ${dy})`)
        g.append(...svg.childNodes);
        return g
      }

      function textFromSpan(string, x, isTitle = false){
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("transform", `translate(${x}, 0)`)
        if (isTitle){
          text.setAttribute("dominant-baseline", "middle")
          text.setAttribute("text-anchor", "middle")
          text.setAttribute("x", "25%");
          text.setAttribute("y", "2%");
        }
        text.append(string);
        return text;
      }

      function gFromSpan(span, spanCount){
        const svg = span.childNodes[0];
        const text = span.childNodes[1];
        const svgBoundingRect = svg.getBoundingClientRect();
        const textBoundingRect = span.getBoundingClientRect();
        const xText = textBoundingRect.width - svgBoundingRect.width;

        var style = window.getComputedStyle(span);
        var dx = int(style.marginLeft) - int(style.marginRight);

        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const x = textBoundingRect.x - textBoundingRect.width - dx * spanCount;
        const y = textBoundingRect.height;
        g.setAttribute("transform", `translate(${x}, ${y})`)
        g.append(gSVGFromSpan(svg));
        g.append(textFromSpan(text, xText))
        return g;
      }

      function gFromObj(obj, lastHeight = 0, layer = 0){
        var childNodes = [];
        var spanCount = 0;
        for (const child of obj.childNodes){
          switch(child.tagName){
            case "SPAN":
              // console.log("SPAN", layer);
              var tmpHeight = child.getBoundingClientRect().height;
              childNodes.push(gFromSpan(child, spanCount));
              spanCount += 1;
              break;
            case "svg":
              // console.log("SVG", layer, lastHeight);
              var tmpHeight = child.getBoundingClientRect().height;
              childNodes.push(gFromSVG(child, lastHeight));
              break;
            case "STYLE":
              // console.log("STYLE", layer);
              break;
            case "DIV":
              // console.log("DIV", layer);
              var tmpHeight = child.getBoundingClientRect().height;
              childNodes.push(...gFromObj(child, lastHeight, layer + 1));
              break;
            case "H2":
              var tmpHeight = child.getBoundingClientRect().height;
              // console.log("H2", layer, tmpHeight);
              childNodes.push(textFromSpan(child.textContent, 0, true));
              break;
            default:
              // console.log("DEFAULT");
              break;
          }
          var lastHeight = tmpHeight;
        }
        return childNodes;
      }

      function gFromGrid(obj, grid){
        var childNodes = [];
        var x = 0;
        var y = 0;
        var maxHeight = 0;
        var index = 0;
        for (const child of obj.childNodes) {
          if (child.tagName === "DIV"){
            var height = child.getBoundingClientRect().height;
            var width = child.childNodes[3].childNodes[0].width.baseVal.value;
            var maxHeight = (index % grid === 0 && index !== 0) ? height: Math.max(maxHeight, height);
            var x = (index % grid === 0) ? 0 : x + width;
            var y = (index % grid === 0 && index !== 0) ? y + maxHeight : y;
            var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("transform", `translate(${x}, ${y})`)
            g.append(...gFromObj(child));
            childNodes.push(g);
            index += 1;
          }
        }
        return [childNodes, x + width, y + height];
      }

      waitForFigure("{{ plot_id }}").then(figure => {
        div = document.getElementById("myplot");
        const svg = figure.childNodes[1];
        // const width = div.getBoundingClientRect().width;
        // const height = div.getBoundingClientRect().height;
        
        const [g, width, height] = gFromGrid(div, 2);
        const new_svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        for (const name of getAttributeNames(svg)){new_svg.setAttribute(name, svg.getAttribute(name));}
        new_svg.setAttribute("width", `${width}`);
        new_svg.setAttribute("height", `${height}`);
        new_svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        new_svg.append(...g);
        div.remove(...div.childNodes)
        document.body.appendChild(new_svg);
        mysvg = serialize(new_svg);
      })
    </script>
