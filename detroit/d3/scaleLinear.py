# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class scaleLinear:
    def __init__(self, content="scaleLinear"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def invert(self, value=None):
        """
        Examples · Source · Given a value from the range, returns the corresponding value from
        the domain. Inversion is useful for interaction, say to determine the data value
        corresponding to the position of the mouse. For example, to invert a position encoding:
        .. code:: javascript

            const x = d3.scaleLinear([10, 130], [0, 960]);
            x.invert(80); // 20
            x.invert(320); // 50

        If the given value is outside the range, and clamping is not enabled, the mapping may
        be extrapolated such that the returned value is outside the domain. This method is only
        supported if the range is numeric. If the range is not numeric, returns NaN.
        For a valid value y in the range, linear(linear.invert(y)) approximately equals y;
        similarly, for a valid value x in the domain, linear.invert(linear(x)) approximately
        equals x. The scale and its inverse may not be exact due to the limitations of floating
        point precision.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_invert>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return scaleLinear(content=f"{self.content}.invert({arguments})")


    def domain(self, domain=None):
        """
        Auto generated method
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (domain,))))
        return scaleLinear(content=f"{self.content}.domain({arguments})")


    def range(self, range=None):
        """
        Examples · Source · If range is specified, sets the scale’s range to the specified
        array of values and returns this scale.
        .. code:: javascript

            const x = d3.scaleLinear().range([0, 960]);

        The array must contain two or more elements. Unlike the domain, elements in the given
        array need not be numbers; any value that is supported by the underlying interpolator
        will work, though note that numeric ranges are required for invert.
        If range is not specified, returns a copy of the scale’s current range.
        .. code:: javascript

            x.range() // [0, 960]

        See linear.interpolate for more examples.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_range>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (range,))))
        return scaleLinear(content=f"{self.content}.range({arguments})")


    def rangeRound(self, range=None):
        """
        Examples · Source · Sets the scale’s range to the specified array of values while also
        setting the scale’s interpolator to interpolateRound; returns this scale.
        .. code:: javascript

            const x = d3.scaleLinear().rangeRound([0, 960]);

        This is a convenience method equivalent to:
        .. code:: javascript

            linear.range(range).interpolate(d3.interpolateRound)

        The rounding interpolator is sometimes useful for avoiding antialiasing artifacts,
        though also consider the shape-rendering “crispEdges” styles. Note that this
        interpolator can only be used with numeric ranges.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_rangeRound>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (range,))))
        return scaleLinear(content=f"{self.content}.rangeRound({arguments})")


    def clamp(self, clamp=None):
        """
        Examples · Source · If clamp is specified, enables or disables clamping accordingly;
        returns this scale.
        .. code:: javascript

            const x = d3.scaleLinear([0, 960]).clamp(true);

        If clamping is disabled and the scale is passed a value outside the domain, the scale
        may return a value outside the range through extrapolation. If clamping is enabled, the
        return value of the scale is always within the scale’s range. Clamping similarly
        applies to linear.invert. For example:
        .. code:: javascript

            const x = d3.scaleLinear([10, 130], [0, 960]); // clamping disabled by default
            x(-10); // -160, outside range
            x.invert(-160); // -10, outside domain
            x.clamp(true); // enable clamping
            x(-10); // 0, clamped to range
            x.invert(-160); // 10, clamped to domain

        If clamp is not specified, returns whether or not the scale currently clamps values to
        within the range.
        .. code:: javascript

            x.clamp() // true, perhaps


        See more informations `here <https://d3js.org/d3-scale/linear#linear_clamp>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (clamp,))))
        return scaleLinear(content=f"{self.content}.clamp({arguments})")


    def unknown(self, value=None):
        """
        Examples · Source · If value is specified, sets the output value of the scale for
        undefined or NaN input values and returns this scale. This is useful for specifying how
        missing or invalid data is displayed.
        .. code:: javascript

            const color = d3.scaleLinear([0, 100], ["red", "blue"]).unknown("#ccc");
            color(NaN); // "#ccc"

        If value is not specified, returns the current unknown value, which defaults to
        undefined.
        .. code:: javascript

            color.unknown() // "#ccc"


        See more informations `here <https://d3js.org/d3-scale/linear#linear_unknown>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return scaleLinear(content=f"{self.content}.unknown({arguments})")


    def interpolate(self, interpolate=None):
        """
        Examples · Source · If interpolate is specified, sets the scale’s range interpolator
        factory.
        .. code:: javascript

            const color = d3.scaleLinear(["red", "blue"]).interpolate(d3.interpolateHcl);

        The scale’s interpolator factory is used to create interpolators for each adjacent pair
        of values from the range; these interpolators then map a normalized domain parameter t
        in [0, 1] to the corresponding value in the range. If factory is not specified, returns
        the scale’s current interpolator factory, which defaults to d3.interpolate. See
        d3-interpolate for more interpolators.
        For example, consider a diverging color scale with three colors in the range:
        .. code:: javascript

            const color = d3.scaleLinear([-100, 0, +100], ["red", "white", "green"]);

        Two interpolators are created internally by the scale, equivalent to:
        .. code:: javascript

            const i0 = d3.interpolate("red", "white");
            const i1 = d3.interpolate("white", "green");

        A common reason to specify a custom interpolator is to change the color space of
        interpolation. For example, to use HCL:
        .. code:: javascript

            const color = d3.scaleLinear()
                .domain([10, 100])
                .range(["brown", "steelblue"])
                .interpolate(d3.interpolateHcl);

        Or for Cubehelix with a custom gamma:
        .. code:: javascript

            const color = d3.scaleLinear()
                .domain([10, 100])
                .range(["brown", "steelblue"])
                .interpolate(d3.interpolateCubehelix.gamma(3));


        See more informations `here <https://d3js.org/d3-scale/linear#linear_interpolate>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (interpolate,))))
        return scaleLinear(content=f"{self.content}.interpolate({arguments})")


    def ticks(self, count=None):
        """
        Examples · Source · Returns approximately count representative values from the scale’s
        domain.
        .. code:: javascript

            const x = d3.scaleLinear([10, 100], ["red", "blue"]);
            x.ticks(); // [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

        If count is not specified, it defaults to 10. The returned tick values are uniformly
        spaced, have human-readable values (such as multiples of powers of 10), and are
        guaranteed to be within the extent of the domain. Ticks are often used to display
        reference lines, or tick marks, in conjunction with the visualized data. The specified
        count is only a hint; the scale may return more or fewer values depending on the
        domain. See also d3-array’s ticks.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_ticks>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (count,))))
        return scaleLinear(content=f"{self.content}.ticks({arguments})")


    def tickFormat(self, count=None, specifier=None):
        """
        Examples · Source · Returns a number format function suitable for displaying a tick
        value, automatically computing the appropriate precision based on the fixed interval
        between tick values. The specified count should have the same value as the count that
        is used to generate the tick values.
        .. code:: javascript

            const x = d3.scaleLinear([0.1, 1], ["red", "blue"]);
            const f = x.tickFormat();
            f(0.1); // "0.1"
            f(1); // "1.0"

        An optional specifier allows a custom format where the precision of the format is
        automatically set by the scale as appropriate for the tick interval. For example, to
        format percentage change, you might say:
        .. code:: javascript

            const x = d3.scaleLinear([-1, 1], [0, 960]);
            const T = x.ticks(5); // [-1, -0.5, 0, 0.5, 1]
            const f = x.tickFormat(5, "+%");
            T.map(f); // ["−100%", "−50%", "+0%", "+50%", "+100%"]

        If specifier uses the format type s, the scale will return a SI-prefix format based on
        the largest value in the domain. If the specifier already specifies a precision, this
        method is equivalent to locale.format.
        See also d3.tickFormat.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_tickFormat>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (count, specifier))))
        return scaleLinear(content=f"{self.content}.tickFormat({arguments})")


    def nice(self):
        """
        Auto generated method
        """
        return scaleLinear(content=f"{self.content}.nice()")


    def copy(self):
        """
        Examples · Source · Returns an exact copy of this scale.
        .. code:: javascript

            const x1 = d3.scaleLinear([0, 100], ["red", "blue"]);
            const x2 = x1.copy();

        Changes to this scale will not affect the returned scale, and vice versa.

        See more informations `here <https://d3js.org/d3-scale/linear#linear_copy>`_.
        """
        return scaleLinear(content=f"{self.content}.copy()")

