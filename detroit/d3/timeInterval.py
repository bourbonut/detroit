# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class timeInterval:
    def __init__(self, content="timeInterval"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def floor(self, date=None):
        """
        .. code:: javascript

            d3.utcMonday.floor(new Date()) // the latest preceding Monday, UTC time

        Source · Returns a new date representing the latest interval boundary date before or
        equal to date. For example, d3.timeDay.floor(date) typically returns 12:00 AM local
        time on the given date.
        This method is idempotent: if the specified date is already floored to the current
        interval, a new date with an identical time is returned. Furthermore, the returned date
        is the minimum expressible value of the associated interval, such that
        interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
        Note that the == and === operators do not compare by value with Date objects, and thus
        you cannot use them to tell whether the specified date has already been floored.
        Instead, coerce to a number and then compare:
        .. code:: javascript

            // Returns true if the specified date is a day boundary.
            function isDay(date) {
              return +d3.timeDay.floor(date) === +date;
            }

        This is more reliable than testing whether the time is 12:00 AM, as in some time zones
        midnight may not exist due to daylight saving.

        See more informations `here <https://d3js.org/d3-time#interval_floor>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (date,))))
        return timeInterval(content=f"{self.content}.floor({arguments})")


    def round(self, date=None):
        """
        .. code:: javascript

            d3.utcMonday.round(new Date()) // the previous or following Monday, whichever is closer

        Source · Returns a new date representing the closest interval boundary date to date.
        For example, d3.timeDay.round(date) typically returns 12:00 AM local time on the given
        date if it is on or before noon, and 12:00 AM of the following day if it is after noon.
        This method is idempotent: if the specified date is already rounded to the current
        interval, a new date with an identical time is returned.

        See more informations `here <https://d3js.org/d3-time#interval_round>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (date,))))
        return timeInterval(content=f"{self.content}.round({arguments})")


    def ceil(self, date=None):
        """
        .. code:: javascript

            d3.utcMonday.ceil(new Date()) // the following Monday

        Source · Returns a new date representing the earliest interval boundary date after or
        equal to date. For example, d3.timeDay.ceil(date) typically returns 12:00 AM local time
        on the date following the given date.
        This method is idempotent: if the specified date is already ceilinged to the current
        interval, a new date with an identical time is returned. Furthermore, the returned date
        is the maximum expressible value of the associated interval, such that
        interval.ceil(interval.ceil(date) + 1) returns the following interval boundary date.

        See more informations `here <https://d3js.org/d3-time#interval_ceil>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (date,))))
        return timeInterval(content=f"{self.content}.ceil({arguments})")


    def offset(self, date=None, step=None):
        """
        .. code:: javascript

            d3.utcDay.offset(new Date(), 1) // the same time tomorrow

        Source · Returns a new date equal to date plus step intervals. If step is not specified
        it defaults to 1. If step is negative, then the returned date will be before the
        specified date; if step is zero, then a copy of the specified date is returned; if step
        is not an integer, it is floored. This method does not round the specified date to the
        interval. For example, if date is today at 5:34 PM, then d3.timeDay.offset(date, 1)
        returns 5:34 PM tomorrow (even if daylight saving changes!).

        See more informations `here <https://d3js.org/d3-time#interval_offset>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (date, step))))
        return timeInterval(content=f"{self.content}.offset({arguments})")


    def range(self, start=None, stop=None, step=None):
        """
        .. code:: javascript

            d3.utcDay.range(new Date("2014-01-01"), new Date("2015-01-01")) // every day in 2014

        Source · Returns an array of dates representing every interval boundary after or equal
        to start (inclusive) and before stop (exclusive). If step is specified, then every
        stepth boundary will be returned; for example, for the d3.timeDay interval a step of 2
        will return every other day. If step is not an integer, it is floored.
        The first date in the returned array is the earliest boundary after or equal to start;
        subsequent dates are offset by step intervals and floored. Thus, two overlapping ranges
        may be consistent. For example, this range contains odd days:
        .. code:: javascript

            d3.timeDay.range(new Date(2015, 0, 1), new Date(2015, 0, 7), 2) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]

        While this contains even days:
        .. code:: javascript

            d3.timeDay.range(new Date(2015, 0, 2), new Date(2015, 0, 8), 2) // [2015-01-02T00:00, 2015-01-04T00:00, 2015-01-06T00:00]

        To make ranges consistent when a step is specified, use interval.every instead.
        For convenience, aliases for interval.range are also provided as plural forms of the
        corresponding interval, such as utcMondays.

        See more informations `here <https://d3js.org/d3-time#interval_range>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (start, stop, step))))
        return timeInterval(content=f"{self.content}.range({arguments})")


    def filter(self, test=None):
        """
        Source · Returns a new interval that is a filtered subset of this interval using the
        specified test function. The test function is passed a date and should return true if
        and only if the specified date should be considered part of the interval. For example,
        to create an interval that returns the 1st, 11th, 21th and 31th (if it exists) of each
        month:
        .. code:: javascript

            d3.timeDay.filter((d) => (d.getDate() - 1) % 10 === 0)

        The returned filtered interval does not support interval.count. See also
        interval.every.

        See more informations `here <https://d3js.org/d3-time#interval_filter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (test,))))
        return timeInterval(content=f"{self.content}.filter({arguments})")


    def every(self, step=None):
        """
        .. code:: javascript

            d3.unixDay.every(3)

        Source · Returns a filtered view of this interval representing every stepth date. The
        meaning of step is dependent on this interval’s parent interval as defined by the field
        function. For example, d3.timeMinute.every(15) returns an interval representing every
        fifteen minutes, starting on the hour: :00, :15, :30, :45, etc. Note that for some
        intervals, the resulting dates may not be uniformly-spaced; d3.timeDay’s parent
        interval is d3.timeMonth, and thus the interval number resets at the start of each
        month. If step is not valid, returns null. If step is one, returns this interval.
        This method can be used in conjunction with interval.range to ensure that two
        overlapping ranges are consistent. For example, this range contains odd days:
        .. code:: javascript

            d3.timeDay.every(2).range(new Date(2015, 0, 1), new Date(2015, 0, 7)) // [2015-01-01T00:00, 2015-01-03T00:00, 2015-01-05T00:00]

        As does this one:
        .. code:: javascript

            d3.timeDay.every(2).range(new Date(2015, 0, 2), new Date(2015, 0, 8)) // [2015-01-03T00:00, 2015-01-05T00:00, 2015-01-07T00:00]

        The returned filtered interval does not support interval.count. See also
        interval.filter.

        See more informations `here <https://d3js.org/d3-time#interval_every>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (step,))))
        return timeInterval(content=f"{self.content}.every({arguments})")


    def count(self, start=None, end=None):
        """
        Source · Returns the number of interval boundaries after start (exclusive) and before
        or equal to end (inclusive). Note that this behavior is slightly different than
        interval.range because its purpose is to return the zero-based number of the specified
        end date relative to the specified start date. For example, to compute the current
        zero-based day-of-year number:
        .. code:: javascript

            d3.timeDay.count(d3.timeYear(now), now) // 177

        Likewise, to compute the current zero-based week-of-year number for weeks that start on
        Sunday:
        .. code:: javascript

            d3.timeSunday.count(d3.timeYear(now), now) // 25


        See more informations `here <https://d3js.org/d3-time#interval_count>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (start, end))))
        return timeInterval(content=f"{self.content}.count({arguments})")

