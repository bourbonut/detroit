# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class geoIdentity:
    def __init__(self, content="geoIdentity"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def invert(self, point=None):
        """
        Source · Returns a new array [longitude, latitude] in degrees representing the
        unprojected point of the given projected point. The point must be specified as a
        two-element array [x, y] (typically in pixels). May return null if the specified point
        has no defined projected position, such as when the point is outside the clipping
        bounds of the projection.
        This method is only defined on invertible projections.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_invert>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (point,))))
        return geoIdentity(content=f"{self.content}.invert({arguments})")


    def stream(self, stream=None):
        """
        Source · Returns a projection stream for the specified output stream. Any input
        geometry is projected before being streamed to the output stream. A typical projection
        involves several geometry transformations: the input geometry is first converted to
        radians, rotated on three axes, clipped to the small circle or cut along the
        antimeridian, and lastly projected to the plane with adaptive resampling, scale and
        translation.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_stream>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (stream,))))
        return geoIdentity(content=f"{self.content}.stream({arguments})")


    def preclip(self, preclip=None):
        """
        If preclip is specified, sets the projection’s spherical clipping to the specified
        function and returns the projection; preclip is a function that takes a projection
        stream and returns a clipped stream. If preclip is not specified, returns the current
        spherical clipping function. Preclipping is commonly used to cut along the antimeridian
        line or along a small circle.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_preclip>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (preclip,))))
        return geoIdentity(content=f"{self.content}.preclip({arguments})")


    def postclip(self, postclip=None):
        """
        If postclip is specified, sets the projection’s Cartesian clipping to the specified
        function and returns the projection; postclip is a function that takes a projection
        stream and returns a clipped stream. If postclip is not specified, returns the current
        Cartesian clipping function. Post-clipping occurs on the plane, when a projection is
        bounded to a certain extent such as a rectangle.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_postclip>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (postclip,))))
        return geoIdentity(content=f"{self.content}.postclip({arguments})")


    def clipAngle(self, angle=None):
        """
        Source · If angle is specified, sets the projection’s clipping circle radius to the
        specified angle in degrees and returns the projection. If angle is null, switches to
        antimeridian cutting rather than small-circle clipping. If angle is not specified,
        returns the current clip angle which defaults to null. Small-circle clipping is
        independent of viewport clipping via projection.clipExtent. See also
        projection.preclip, geoClipAntimeridian, geoClipCircle.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_clipAngle>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (angle,))))
        return geoIdentity(content=f"{self.content}.clipAngle({arguments})")


    def clipExtent(self, extent=None):
        """
        Source · If extent is specified, sets the projection’s viewport clip extent to the
        specified bounds in pixels and returns the projection. The extent bounds are specified
        as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the
        top, x₁ is the right and y₁ is the bottom. If extent is null, no viewport clipping is
        performed. If extent is not specified, returns the current viewport clip extent which
        defaults to null. Viewport clipping is independent of small-circle clipping via
        projection.clipAngle. See also projection.postclip, geoClipRectangle.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_clipExtent>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (extent,))))
        return geoIdentity(content=f"{self.content}.clipExtent({arguments})")


    def scale(self, scale=None):
        """
        Source · If scale is specified, sets the projection’s scale factor to the specified
        value and returns the projection. If scale is not specified, returns the current scale
        factor; the default scale is projection-specific. The scale factor corresponds linearly
        to the distance between projected points; however, absolute scale factors are not
        equivalent across projections.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_scale>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (scale,))))
        return geoIdentity(content=f"{self.content}.scale({arguments})")


    def translate(self, translate=None):
        """
        Source · If translate is specified, sets the projection’s translation offset to the
        specified two-element array [tx, ty] and returns the projection. If translate is not
        specified, returns the current translation offset which defaults to [480, 250]. The
        translation offset determines the pixel coordinates of the projection’s center. The
        default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_translate>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (translate,))))
        return geoIdentity(content=f"{self.content}.translate({arguments})")


    def center(self, center=None):
        """
        Source · If center is specified, sets the projection’s center to the specified center,
        a two-element array of [longitude, latitude] in degrees and returns the projection. If
        center is not specified, returns the current center, which defaults to ⟨0°,0°⟩.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_center>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (center,))))
        return geoIdentity(content=f"{self.content}.center({arguments})")


    def angle(self, angle=None):
        """
        Source · If angle is specified, sets the projection’s post-projection planar rotation
        angle to the specified angle in degrees and returns the projection. If angle is not
        specified, returns the projection’s current angle, which defaults to 0°. Note that it
        may be faster to rotate during rendering (e.g., using context.rotate) rather than
        during projection.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_angle>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (angle,))))
        return geoIdentity(content=f"{self.content}.angle({arguments})")


    def reflectX(self, reflect=None):
        """
        If reflect is specified, sets whether or not the x-dimension is reflected (negated) in
        the output. If reflect is not specified, returns true if x-reflection is enabled, which
        defaults to false. This can be useful to display sky and astronomical data with the orb
        seen from below: right ascension (eastern direction) will point to the left when North
        is pointing up.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_reflectX>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (reflect,))))
        return geoIdentity(content=f"{self.content}.reflectX({arguments})")


    def reflectY(self, reflect=None):
        """
        If reflect is specified, sets whether or not the y-dimension is reflected (negated) in
        the output. If reflect is not specified, returns true if y-reflection is enabled, which
        defaults to false. This is especially useful for transforming from standard spatial
        reference systems, which treat positive y as pointing up, to display coordinate systems
        such as Canvas and SVG, which treat positive y as pointing down.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_reflectY>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (reflect,))))
        return geoIdentity(content=f"{self.content}.reflectY({arguments})")


    def rotate(self, angles=None):
        """
        Source · If rotation is specified, sets the projection’s three-axis spherical rotation
        to the specified angles, which must be a two- or three-element array of numbers
        [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical
        axis. (These correspond to yaw, pitch and roll.) If the rotation angle gamma is
        omitted, it defaults to 0. See also geoRotation. If rotation is not specified, returns
        the current rotation which defaults [0, 0, 0].

        See more informations `here <https://d3js.org/d3-geo/projection#projection_rotate>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (angles,))))
        return geoIdentity(content=f"{self.content}.rotate({arguments})")


    def precision(self, precision=None):
        """
        Source · If precision is specified, sets the threshold for the projection’s adaptive
        resampling to the specified value in pixels and returns the projection. This value
        corresponds to the Douglas–Peucker distance. If precision is not specified, returns the
        projection’s current resampling precision which defaults to √0.5 ≅ 0.70710…

        See more informations `here <https://d3js.org/d3-geo/projection#projection_precision>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (precision,))))
        return geoIdentity(content=f"{self.content}.precision({arguments})")


    def fitExtent(self, extent=None, object=None):
        """
        Source · Sets the projection’s scale and translate to fit the specified GeoJSON object
        in the center of the given extent. The extent is specified as an array [[x₀, y₀], [x₁,
        y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and
        y₁ is the bottom. Returns the projection.
        For example, to scale and translate the New Jersey State Plane projection to fit a
        GeoJSON object nj in the center of a 960×500 bounding box with 20 pixels of padding on
        each side:
        .. code:: javascript

            var projection = d3.geoTransverseMercator()
                .rotate([74 + 30 / 60, -38 - 50 / 60])
                .fitExtent([[20, 20], [940, 480]], nj);

        Any clip extent is ignored when determining the new scale and translate. The precision
        used to compute the bounding box of the given object is computed at an effective scale
        of 150.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_fitExtent>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (extent, object))))
        return geoIdentity(content=f"{self.content}.fitExtent({arguments})")


    def fitSize(self, size=None, object=None):
        """
        Source · A convenience method for projection.fitExtent where the top-left corner of the
        extent is [0, 0]. The following two statements are equivalent:
        .. code:: javascript

            projection.fitExtent([[0, 0], [width, height]], object);
            projection.fitSize([width, height], object);


        See more informations `here <https://d3js.org/d3-geo/projection#projection_fitSize>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (size, object))))
        return geoIdentity(content=f"{self.content}.fitSize({arguments})")


    def fitWidth(self, width=None, object=None):
        """
        Source · A convenience method for projection.fitSize where the height is automatically
        chosen from the aspect ratio of object and the given constraint on width.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_fitWidth>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (width, object))))
        return geoIdentity(content=f"{self.content}.fitWidth({arguments})")


    def fitHeight(self, height=None, object=None):
        """
        Source · A convenience method for projection.fitSize where the width is automatically
        chosen from the aspect ratio of object and the given constraint on height.

        See more informations `here <https://d3js.org/d3-geo/projection#projection_fitHeight>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (height, object))))
        return geoIdentity(content=f"{self.content}.fitHeight({arguments})")

