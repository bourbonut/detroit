# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class transition:
    def __init__(self, content="transition"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def select(self, selector=None):
        """
        Source · For each selected element, selects the first descendant element that matches
        the specified selector string, if any, and returns a transition on the resulting
        selection. The selector may be specified either as a selector string or a function. If
        a function, it is evaluated for each selected element, in order, being passed the
        current datum (d), the current index (i), and the current group (nodes), with this as
        the current DOM element. The new transition has the same id, name and timing as this
        transition; however, if a transition with the same id already exists on a selected
        element, the existing transition is returned for that element.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, creating a subselection via selection.select, and then creating a
        new transition via selection.transition:
        .. code:: javascript

            transition
              .selection()
              .select(selector)
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_select>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return transition(content=f"{self.content}.select({arguments})")


    def selectAll(self, selector=None):
        """
        Source · For each selected element, selects all descendant elements that match the
        specified selector string, if any, and returns a transition on the resulting selection.
        The selector may be specified either as a selector string or a function. If a function,
        it is evaluated for each selected element, in order, being passed the current datum
        (d), the current index (i), and the current group (nodes), with this as the current DOM
        element. The new transition has the same id, name and timing as this transition;
        however, if a transition with the same id already exists on a selected element, the
        existing transition is returned for that element.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, creating a subselection via selection.selectAll, and then
        creating a new transition via selection.transition:
        .. code:: javascript

            transition
              .selection()
              .selectAll(selector)
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_selectAll>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return transition(content=f"{self.content}.selectAll({arguments})")


    def selectChild(self, selector=None):
        """
        Source · For each selected element, selects the first child element that matches the
        specified selector string, if any, and returns a transition on the resulting selection.
        The selector may be specified either as a selector string or a function. If a function,
        it is evaluated for each selected element, in order, being passed the current datum
        (d), the current index (i), and the current group (nodes), with this as the current DOM
        element. The new transition has the same id, name and timing as this transition;
        however, if a transition with the same id already exists on a selected element, the
        existing transition is returned for that element.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, creating a subselection via selection.selectChild, and then
        creating a new transition via selection.transition:
        .. code:: javascript

            transition
              .selection()
              .selectChild(selector)
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_selectChild>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return transition(content=f"{self.content}.selectChild({arguments})")


    def selectChildren(self, selector=None):
        """
        Source · For each selected element, selects all children that match the specified
        selector string, if any, and returns a transition on the resulting selection. The
        selector may be specified either as a selector string or a function. If a function, it
        is evaluated for each selected element, in order, being passed the current datum (d),
        the current index (i), and the current group (nodes), with this as the current DOM
        element. The new transition has the same id, name and timing as this transition;
        however, if a transition with the same id already exists on a selected element, the
        existing transition is returned for that element.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, creating a subselection via selection.selectChildren, and then
        creating a new transition via selection.transition:
        .. code:: javascript

            transition
              .selection()
              .selectChildren(selector)
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_selectChildren>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return transition(content=f"{self.content}.selectChildren({arguments})")


    def selection(self):
        """
        Source · Returns the selection corresponding to this transition.

        See more informations `here <https://d3js.org/d3-transition/selecting#transition_selection>`_.
        """
        return transition(content=f"{self.content}.selection()")


    def filter(self, filter=None):
        """
        Source · For each selected element, selects only the elements that match the specified
        filter, and returns a transition on the resulting selection. The filter may be
        specified either as a selector string or a function. If a function, it is evaluated for
        each selected element, in order, being passed the current datum (d), the current index
        (i), and the current group (nodes), with this as the current DOM element. The new
        transition has the same id, name and timing as this transition; however, if a
        transition with the same id already exists on a selected element, the existing
        transition is returned for that element.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, creating a subselection via selection.filter, and then creating a
        new transition via selection.transition:
        .. code:: javascript

            transition
              .selection()
              .filter(filter)
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_filter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (filter,))))
        return transition(content=f"{self.content}.filter({arguments})")


    def merge(self, other=None):
        """
        Source · Returns a new transition merging this transition with the specified other
        transition, which must have the same id as this transition. The returned transition has
        the same number of groups, the same parents, the same name and the same id as this
        transition. Any missing (null) elements in this transition are filled with the
        corresponding element, if present (not null), from the other transition.
        This method is equivalent to deriving the selection for this transition via
        transition.selection, merging with the selection likewise derived from the other
        transition via selection.merge, and then creating a new transition via
        selection.transition:
        .. code:: javascript

            transition
              .selection()
              .merge(other.selection())
              .transition(transition)


        See more informations `here <https://d3js.org/d3-transition/selecting#transition_merge>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (other,))))
        return transition(content=f"{self.content}.merge({arguments})")


    def transition(self):
        """
        Source · Returns a new transition on the same selected elements as this transition,
        scheduled to start when this transition ends. The new transition inherits a reference
        time equal to this transition’s time plus its delay and duration. The new transition
        also inherits this transition’s name, duration, and easing. This method can be used to
        schedule a sequence of chained transitions. For example:
        .. code:: javascript

            d3.selectAll(".apple")
              .transition() // First fade to green.
                .style("fill", "green")
              .transition() // Then red.
                .style("fill", "red")
              .transition() // Wait one second. Then brown, and remove.
                .delay(1000)
                .style("fill", "brown")
                .remove();

        The delay for each transition is relative to its previous transition. Thus, in the
        above example, apples will stay red for one second before the last transition to brown
        starts.

        See more informations `here <https://d3js.org/d3-transition/selecting#transition_transition>`_.
        """
        return transition(content=f"{self.content}.transition()")


    def attr(self, name=None, value=None):
        """
        Source · For each selected element, assigns the attribute tween for the attribute with
        the specified name to the specified target value. The starting value of the tween is
        the attribute’s value when the transition starts. The target value may be specified
        either as a constant or a function. If a function, it is immediately evaluated for each
        selected element, in order, being passed the current datum (d), the current index (i),
        and the current group (nodes), with this as the current DOM element.
        If the target value is null, the attribute is removed when the transition starts.
        Otherwise, an interpolator is chosen based on the type of the target value, using the
        following algorithm:
        To apply a different interpolator, use transition.attrTween.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_attr>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value))))
        return transition(content=f"{self.content}.attr({arguments})")


    def attrTween(self, name=None, factory=None):
        """
        Source · If factory is specified and not null, assigns the attribute tween for the
        attribute with the specified name to the specified interpolator factory. An
        interpolator factory is a function that returns an interpolator; when the transition
        starts, the factory is evaluated for each selected element, in order, being passed the
        current datum (d), the current index (i), and the current group (nodes), with this as
        the current DOM element. The returned interpolator will then be invoked for each frame
        of the transition, in order, being passed the eased time t, typically in the range [0,
        1]. Lastly, the return value of the interpolator will be used to set the attribute
        value. The interpolator must return a string. (To remove an attribute at the start of a
        transition, use transition.attr; to remove an attribute at the end of a transition, use
        transition.on to listen for the end event.)
        If the specified factory is null, removes the previously-assigned attribute tween of
        the specified name, if any. If factory is not specified, returns the current
        interpolator factory for attribute with the specified name, or undefined if no such
        tween exists.
        For example, to interpolate the fill attribute from red to blue:
        .. code:: javascript

            transition.attrTween("fill", () => d3.interpolateRgb("red", "blue"));

        Or to interpolate from the current fill to blue, like transition.attr:
        .. code:: javascript

            transition.attrTween("fill", function() {
              return d3.interpolateRgb(this.getAttribute("fill"), "blue");
            });

        Or to apply a custom rainbow interpolator:
        .. code:: javascript

            transition.attrTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);

        This method is useful to specify a custom interpolator, such as one that understands
        SVG paths. A useful technique is data interpolation, where interpolateObject is used to
        interpolate two data values, and the resulting value is then used (say, with a shape)
        to compute the new attribute value.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_attrTween>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, factory))))
        return transition(content=f"{self.content}.attrTween({arguments})")


    def style(self, name=None, value=None, priority=None):
        """
        Source · For each selected element, assigns the style tween for the style with the
        specified name to the specified target value with the specified priority. The starting
        value of the tween is the style’s inline value if present, and otherwise its computed
        value, when the transition starts. The target value may be specified either as a
        constant or a function. If a function, it is immediately evaluated for each selected
        element, in order, being passed the current datum (d), the current index (i), and the
        current group (nodes), with this as the current DOM element.
        If the target value is null, the style is removed when the transition starts.
        Otherwise, an interpolator is chosen based on the type of the target value, using the
        following algorithm:
        To apply a different interpolator, use transition.styleTween.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_style>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value, priority))))
        return transition(content=f"{self.content}.style({arguments})")


    def styleTween(self, name=None, factory=None, priority=None):
        """
        Source · If factory is specified and not null, assigns the style tween for the style
        with the specified name to the specified interpolator factory. An interpolator factory
        is a function that returns an interpolator; when the transition starts, the factory is
        evaluated for each selected element, in order, being passed the current datum (d), the
        current index (i), and the current group (nodes), with this as the current DOM element.
        The returned interpolator will then be invoked for each frame of the transition, in
        order, being passed the eased time t, typically in the range [0, 1]. Lastly, the return
        value of the interpolator will be used to set the style value with the specified
        priority. The interpolator must return a string. (To remove an style at the start of a
        transition, use transition.style; to remove an style at the end of a transition, use
        transition.on to listen for the end event.)
        If the specified factory is null, removes the previously-assigned style tween of the
        specified name, if any. If factory is not specified, returns the current interpolator
        factory for style with the specified name, or undefined if no such tween exists.
        For example, to interpolate the fill style from red to blue:
        .. code:: javascript

            transition.styleTween("fill", () => d3.interpolateRgb("red", "blue"));

        Or to interpolate from the current fill to blue, like transition.style:
        .. code:: javascript

            transition.styleTween("fill", function() {
              return d3.interpolateRgb(this.style.fill, "blue");
            });

        Or to apply a custom rainbow interpolator:
        .. code:: javascript

            transition.styleTween("fill", () => (t) => `hsl(${t * 360},100%,50%)`);

        This method is useful to specify a custom interpolator, such as with data
        interpolation, where interpolateObject is used to interpolate two data values, and the
        resulting value is then used to compute the new style value.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_styleTween>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, factory, priority))))
        return transition(content=f"{self.content}.styleTween({arguments})")


    def text(self, value=None):
        """
        Source · For each selected element, sets the text content to the specified target value
        when the transition starts. The value may be specified either as a constant or a
        function. If a function, it is immediately evaluated for each selected element, in
        order, being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element. The function’s return value is then used
        to set each element’s text content. A null value will clear the content.
        To interpolate text rather than to set it on start, use transition.textTween or append
        a replacement element and cross-fade opacity. Text is not interpolated by default
        because it is usually undesirable.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_text>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return transition(content=f"{self.content}.text({arguments})")


    def textTween(self, factory=None):
        """
        Source, Examples
        If factory is specified and not null, assigns the text tween to the specified
        interpolator factory. An interpolator factory is a function that returns an
        interpolator; when the transition starts, the factory is evaluated for each selected
        element, in order, being passed the current datum d and index i, with the this context
        as the current DOM element. The returned interpolator will then be invoked for each
        frame of the transition, in order, being passed the eased time t, typically in the
        range [0, 1]. Lastly, the return value of the interpolator will be used to set the
        text. The interpolator must return a string.
        For example, to interpolate the text with integers from 0 to 100:
        .. code:: javascript

            transition.textTween(() => d3.interpolateRound(0, 100));

        If the specified factory is null, removes the previously-assigned text tween, if any.
        If factory is not specified, returns the current interpolator factory for text, or
        undefined if no such tween exists.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_textTween>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (factory,))))
        return transition(content=f"{self.content}.textTween({arguments})")


    def remove(self):
        """
        Source · For each selected element, removes the element when the transition ends, as
        long as the element has no other active or pending transitions. If the element has
        other active or pending transitions, does nothing.

        See more informations `here <https://d3js.org/d3-transition/modifying#transition_remove>`_.
        """
        return transition(content=f"{self.content}.remove()")


    def tween(self, name=None, value=None):
        """
        Source · For each selected element, assigns the tween with the specified name with the
        specified value function. The value must be specified as a function that returns a
        function. When the transition starts, the value function is evaluated for each selected
        element, in order, being passed the current datum (d), the current index (i), and the
        current group (nodes), with this as the current DOM element. The returned function is
        then invoked for each frame of the transition, in order, being passed the eased time t,
        typically in the range [0, 1]. If the specified value is null, removes the
        previously-assigned tween of the specified name, if any.
        For example, to interpolate the fill attribute to blue, like transition.attr:
        .. code:: javascript

            transition.tween("attr.fill", function() {
              const i = d3.interpolateRgb(this.getAttribute("fill"), "blue");
              return function(t) {
                this.setAttribute("fill", i(t));
              };
            });


        See more informations `here <https://d3js.org/d3-transition/modifying#transition_tween>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value))))
        return transition(content=f"{self.content}.tween({arguments})")


    def delay(self, value=None):
        """
        Source · For each selected element, sets the transition delay to the specified value in
        milliseconds.
        .. code:: javascript

            transition.delay(250);

        The value may be specified either as a constant or a function. If a function, it is
        immediately evaluated for each selected element, in order, being passed the current
        datum (d), the current index (i), and the current group (nodes), with this as the
        current DOM element. The function’s return value is then used to set each element’s
        transition delay. If a delay is not specified, it defaults to zero.
        If a value is not specified, returns the current value of the delay for the first
        (non-null) element in the transition. This is generally useful only if you know that
        the transition contains exactly one element.
        .. code:: javascript

            transition.delay() // 250

        Setting the delay to a multiple of the index i is a convenient way to stagger
        transitions across a set of elements. For example:
        .. code:: javascript

            transition.delay((d, i) => i * 10);

        Of course, you can also compute the delay as a function of the data, or sort the
        selection before computed an index-based delay.

        See more informations `here <https://d3js.org/d3-transition/timing#transition_delay>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return transition(content=f"{self.content}.delay({arguments})")


    def duration(self, value=None):
        """
        Source · For each selected element, sets the transition duration to the specified value
        in milliseconds.
        .. code:: javascript

            transition.duration(750);

        The value may be specified either as a constant or a function. If a function, it is
        immediately evaluated for each selected element, in order, being passed the current
        datum (d), the current index (i), and the current group (nodes), with this as the
        current DOM element. The function’s return value is then used to set each element’s
        transition duration. If a duration is not specified, it defaults to 250ms.
        If a value is not specified, returns the current value of the duration for the first
        (non-null) element in the transition. This is generally useful only if you know that
        the transition contains exactly one element.
        .. code:: javascript

            transition.duration() // 750


        See more informations `here <https://d3js.org/d3-transition/timing#transition_duration>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return transition(content=f"{self.content}.duration({arguments})")


    def ease(self, value=None):
        """
        Source · Specifies the transition easing function for all selected elements.
        .. code:: javascript

            transition.ease(d3.easeCubic);

        The value must be specified as a function. The easing function is invoked for each
        frame of the animation, being passed the normalized time t in the range [0, 1]; it must
        then return the eased time tʹ which is typically also in the range [0, 1]. A good
        easing function should return 0 if t = 0 and 1 if t = 1. If an easing function is not
        specified, it defaults to easeCubic.
        If a value is not specified, returns the current easing function for the first
        (non-null) element in the transition. This is generally useful only if you know that
        the transition contains exactly one element.
        .. code:: javascript

            transition.ease() // d3.easeCubic


        See more informations `here <https://d3js.org/d3-transition/timing#transition_ease>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return transition(content=f"{self.content}.ease({arguments})")


    def easeVarying(self, factory=None):
        """
        Examples · Source · Specifies a factory for the transition easing function.
        .. code:: javascript

            transition.easeVarying((d) => d3.easePolyIn.exponent(d.exponent));

        The factory must be a function. It is invoked for each node of the selection, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element. It must return an easing function.

        See more informations `here <https://d3js.org/d3-transition/timing#transition_easeVarying>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (factory,))))
        return transition(content=f"{self.content}.easeVarying({arguments})")


    def end(self):
        """
        Source · Returns a promise that resolves when every selected element finishes
        transitioning. If any element’s transition is cancelled or interrupted, the promise
        rejects.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_end>`_.
        """
        return transition(content=f"{self.content}.end()")


    def on(self, typenames=None, listener=None):
        """
        Source · Adds or removes a listener to each selected element for the specified event
        typenames. The typenames is one of the following string event types:
        See The Life of a Transition for more. Note that these are not native DOM events as
        implemented by selection.on and selection.dispatch, but transition events!
        The type may be optionally followed by a period (.) and a name; the optional name
        allows multiple callbacks to be registered to receive events of the same type, such as
        start.foo and start.bar. To specify multiple typenames, separate typenames with spaces,
        such as interrupt end or start.foo start.bar.
        When a specified transition event is dispatched on a selected node, the specified
        listener will be invoked for the transitioning element, being passed the current datum
        (d), the current index (i), and the current group (nodes), with this as the current DOM
        element. Listeners always see the latest datum for their element, but the index is a
        property of the selection and is fixed when the listener is assigned; to update the
        index, re-assign the listener.
        If an event listener was previously registered for the same typename on a selected
        element, the old listener is removed before the new listener is added. To remove a
        listener, pass null as the listener. To remove all listeners for a given name, pass
        null as the listener and .foo as the typename, where foo is the name; to remove all
        listeners with no name, specify . as the typename.
        If a listener is not specified, returns the currently-assigned listener for the
        specified event typename on the first (non-null) selected element, if any. If multiple
        typenames are specified, the first matching listener is returned.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_on>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (typenames, listener))))
        return transition(content=f"{self.content}.on({arguments})")


    def each(self, function=None):
        """
        Source · Invokes the specified function for each selected element, passing in the
        current datum (d), the current index (i), and the current group (nodes), with this as
        the current DOM element. This method can be used to invoke arbitrary code for each
        selected element, and is useful for creating a context to access parent and child data
        simultaneously. Equivalent to selection.each.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_each>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function,))))
        return transition(content=f"{self.content}.each({arguments})")


    def call(self, function=None, *arguments):
        """
        Source · Invokes the specified function exactly once, passing in this transition along
        with any optional arguments. Returns this transition. This is equivalent to invoking
        the function by hand but facilitates method chaining. For example, to set several
        attributes in a reusable function:
        .. code:: javascript

            function color(transition, fill, stroke) {
              transition
                  .style("fill", fill)
                  .style("stroke", stroke);
            }

        Now say:
        .. code:: javascript

            d3.selectAll("div").transition().call(color, "red", "blue");

        This is equivalent to:
        .. code:: javascript

            color(d3.selectAll("div").transition(), "red", "blue");

        Equivalent to selection.call.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_call>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function, *arguments))))
        return transition(content=f"{self.content}.call({arguments})")


    def empty(self):
        """
        Source · Returns true if this transition contains no (non-null) elements. Equivalent to
        selection.empty.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_empty>`_.
        """
        return transition(content=f"{self.content}.empty()")


    def nodes(self):
        """
        Source · Returns an array of all (non-null) elements in this transition. Equivalent to
        selection.nodes.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_nodes>`_.
        """
        return transition(content=f"{self.content}.nodes()")


    def node(self):
        """
        Source · Returns the first (non-null) element in this transition. If the transition is
        empty, returns null. Equivalent to selection.node.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_node>`_.
        """
        return transition(content=f"{self.content}.node()")


    def size(self):
        """
        Source · Returns the total number of elements in this transition. Equivalent to
        selection.size.

        See more informations `here <https://d3js.org/d3-transition/control-flow#transition_size>`_.
        """
        return transition(content=f"{self.content}.size()")

