# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class forceManyBody:
    def __init__(self, content="forceManyBody"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def strength(self, strength=None):
        """
        Source · If strength is specified, sets the strength accessor to the specified number
        or function, re-evaluates the strength accessor for each node, and returns this force.
        The strength determines how much to increment the node’s y-velocity: (y - node.y) ×
        strength. For example, a value of 0.1 indicates that the node should move a tenth of
        the way from its current y-position to the target y-position with each application.
        Higher values moves nodes more quickly to the target position, often at the expense of
        other forces or constraints. A value outside the range [0,1] is not recommended.
        If strength is not specified, returns the current strength accessor, which defaults to:
        .. code:: javascript

            function strength() {
              return 0.1;
            }

        The strength accessor is invoked for each node in the simulation, being passed the node
        and its zero-based index. The resulting number is then stored internally, such that the
        strength of each node is only recomputed when the force is initialized or when this
        method is called with a new strength, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/position#y_strength>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (strength,))))
        return forceManyBody(content=f"{self.content}.strength({arguments})")


    def theta(self, theta=None):
        """
        Source · If theta is specified, sets the Barnes–Hut approximation criterion to the
        specified number and returns this force. If theta is not specified, returns the current
        value, which defaults to 0.9.
        To accelerate computation, this force implements the Barnes–Hut approximation which
        takes O(n log n) per application where n is the number of nodes. For each application,
        a quadtree stores the current node positions; then for each node, the combined force of
        all other nodes on the given node is computed. For a cluster of nodes that is far away,
        the charge force can be approximated by treating the cluster as a single, larger node.
        The theta parameter determines the accuracy of the approximation: if the ratio w / l of
        the width w of the quadtree cell to the distance l from the node to the cell’s center
        of mass is less than theta, all nodes in the given cell are treated as a single node
        rather than individually.

        See more informations `here <https://d3js.org/d3-force/many-body#manyBody_theta>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (theta,))))
        return forceManyBody(content=f"{self.content}.theta({arguments})")


    def distanceMin(self, distance=None):
        """
        Source · If distance is specified, sets the minimum distance between nodes over which
        this force is considered. If distance is not specified, returns the current minimum
        distance, which defaults to 1. A minimum distance establishes an upper bound on the
        strength of the force between two nearby nodes, avoiding instability. In particular, it
        avoids an infinitely-strong force if two nodes are exactly coincident; in this case,
        the direction of the force is random.

        See more informations `here <https://d3js.org/d3-force/many-body#manyBody_distanceMin>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (distance,))))
        return forceManyBody(content=f"{self.content}.distanceMin({arguments})")


    def distanceMax(self, distance=None):
        """
        Source · If distance is specified, sets the maximum distance between nodes over which
        this force is considered. If distance is not specified, returns the current maximum
        distance, which defaults to infinity. Specifying a finite maximum distance improves
        performance and produces a more localized layout.

        See more informations `here <https://d3js.org/d3-force/many-body#manyBody_distanceMax>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (distance,))))
        return forceManyBody(content=f"{self.content}.distanceMax({arguments})")


    def y(self, y=None):
        """
        Source · If y is specified, sets the y-coordinate accessor to the specified number or
        function, re-evaluates the y-accessor for each node, and returns this force. If y is
        not specified, returns the current y-accessor, which defaults to:
        .. code:: javascript

            function y() {
              return 0;
            }

        The y-accessor is invoked for each node in the simulation, being passed the node and
        its zero-based index. The resulting number is then stored internally, such that the
        target y coordinate of each node is only recomputed when the force is initialized or
        when this method is called with a new y, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/position#y_y>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (y,))))
        return forceManyBody(content=f"{self.content}.y({arguments})")

