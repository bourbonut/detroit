# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class select:
    def __init__(self, content="select"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def select(self, selector=None):
        """
        Source · For each selected element, selects the first descendant element that matches
        the specified selector string.
        .. code:: javascript

            const b = d3.selectAll("p").select("b"); // the first <b> in every <p>

        If no element matches the specified selector for the current element, the element at
        the current index will be null in the returned selection. (If the selector is null,
        every element in the returned selection will be null, resulting in an empty selection.)
        If the current element has associated data, this data is propagated to the
        corresponding selected element. If multiple elements match the selector, only the first
        matching element in document order is selected.
        If the selector is a function, it is evaluated for each selected element, in order,
        being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). It must return an element, or
        null if there is no matching element. For example, to select the previous sibling of
        each paragraph:
        .. code:: javascript

            const previous = d3.selectAll("p").select(function() {
              return this.previousElementSibling;
            });

        Unlike selection.selectAll, selection.select does not affect grouping: it preserves the
        existing group structure and indexes, and propagates data (if any) to selected
        children. Grouping plays an important role in the data join. See Nested Selections and
        How Selections Work for more on this topic.

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_select>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return select(content=f"{self.content}.select({arguments})")


    def selectAll(self, selector=None):
        """
        Source · For each selected element, selects the descendant elements that match the
        specified selector string.
        .. code:: javascript

            const b = d3.selectAll("p").selectAll("b"); // every <b> in every <p>

        The elements in the returned selection are grouped by their corresponding parent node
        in this selection. If no element matches the specified selector for the current
        element, or if the selector is null, the group at the current index will be empty. The
        selected elements do not inherit data from this selection; use selection.data to
        propagate data to children.
        If the selector is a function, it is evaluated for each selected element, in order,
        being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). It must return an array of
        elements (or an iterable, or a pseudo-array such as a NodeList), or the empty array if
        there are no matching elements. For example, to select the previous and next siblings
        of each paragraph:
        .. code:: javascript

            const sibling = d3.selectAll("p").selectAll(function() {
              return [
                this.previousElementSibling,
                this.nextElementSibling
              ];
            });

        Unlike selection.select, selection.selectAll does affect grouping: each selected
        descendant is grouped by the parent element in the originating selection. Grouping
        plays an important role in the data join. See Nested Selections and How Selections Work
        for more on this topic.

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_selectAll>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return select(content=f"{self.content}.selectAll({arguments})")


    def filter(self, filter=None):
        """
        Source · Filters the selection, returning a new selection that contains only the
        elements for which the specified filter is true. For example, to filter a selection of
        table rows to contain only even rows:
        .. code:: javascript

            const even = d3.selectAll("tr").filter(":nth-child(even)");

        This is approximately equivalent to using d3.selectAll directly, although the indexes
        may be different:
        .. code:: javascript

            const even = d3.selectAll("tr:nth-child(even)");

        The filter may be specified either as a selector string or a function. If the filter is
        a function, it is evaluated for each selected element, in order, being passed the
        current datum (d), the current index (i), and the current group (nodes), with this as
        the current DOM element (nodes[i]). Using a function:
        .. code:: javascript

            const even = d3.selectAll("tr").filter((d, i) => i & 1);

        Or using selection.select (and avoiding an arrow function, since this is needed to
        refer to the current element):
        .. code:: javascript

            const even = d3.selectAll("tr").select(function(d, i) { return i & 1 ? this : null; });

        Note that the :nth-child pseudo-class is a one-based index rather than a zero-based
        index. Also, the above filter functions do not have precisely the same meaning as
        :nth-child; they rely on the selection index rather than the number of preceding
        sibling elements in the DOM.
        The returned filtered selection preserves the parents of this selection, but like
        array.filter, it does not preserve indexes as some elements may be removed; use
        selection.select to preserve the index, if needed.

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_filter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (filter,))))
        return select(content=f"{self.content}.filter({arguments})")


    def merge(self, other=None):
        """
        Source · Returns a new selection merging this selection with the specified other
        selection or transition. The returned selection has the same number of groups and the
        same parents as this selection. Any missing (null) elements in this selection are
        filled with the corresponding element, if present (not null), from the specified
        selection. (If the other selection has additional groups or parents, they are ignored.)
        This method is used internally by selection.join to merge the enter and update
        selections after binding data. You can also merge explicitly, although note that since
        merging is based on element index, you should use operations that preserve index, such
        as selection.select instead of selection.filter. For example:
        .. code:: javascript

            const odd = selection.select(function(d, i) { return i & 1 ? this : null; ));
            const even = selection.select(function(d, i) { return i & 1 ? null : this; ));
            const merged = odd.merge(even);

        See selection.data for more.
        This method is not intended for concatenating arbitrary selections, however: if both
        this selection and the specified other selection have (non-null) elements at the same
        index, this selection’s element is returned in the merge and the other selection’s
        element is ignored.

        See more informations `here <https://d3js.org/d3-selection/joining#selection_merge>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (other,))))
        return select(content=f"{self.content}.merge({arguments})")


    def selectChild(self, selector=None):
        """
        Source · Returns a new selection with the (first) child of each element of the current
        selection matching the selector.
        .. code:: javascript

            d3.selectAll("p").selectChild("b") // the first <b> child of every <p>

        If no selector is specified, selects the first child (if any). If the selector is
        specified as a string, selects the first child that matches (if any). If the selector
        is a function, it is evaluated for each of the children nodes, in order, being passed
        the child (child), the child’s index (i), and the list of children (children); the
        method selects the first child for which the selector return truthy, if any.

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_selectChild>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return select(content=f"{self.content}.selectChild({arguments})")


    def selectChildren(self, selector=None):
        """
        Source · Returns a new selection with the children of each element of the current
        selection matching the selector. If no selector is specified, selects all the children.
        If the selector is specified as a string, selects the children that match (if any). If
        the selector is a function, it is evaluated for each of the children nodes, in order,
        being passed the child (child), the child’s index (i), and the list of children
        (children); the method selects all children for which the selector return truthy.

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_selectChildren>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (selector,))))
        return select(content=f"{self.content}.selectChildren({arguments})")


    def selection(self):
        """
        Source · Returns the selection (for symmetry with transition.selection).

        See more informations `here <https://d3js.org/d3-selection/selecting#selection_selection>`_.
        """
        return select(content=f"{self.content}.selection()")


    def attr(self, name=None, value=None):
        """
        Source · If a value is specified, sets the attribute with the specified name to the
        specified value on the selected elements and returns this selection.
        .. code:: javascript

            selection.attr("color", "red")

        If the value is a constant, all elements are given the same attribute value; otherwise,
        if the value is a function, it is evaluated for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]). The function’s return value is then
        used to set each element’s attribute. A null value will remove the specified attribute.
        .. code:: javascript

            selection.attr("color") // "red"

        If a value is not specified, returns the current value of the specified attribute for
        the first (non-null) element in the selection. This is generally useful only if you
        know that the selection contains exactly one element.
        The specified name may have a namespace prefix, such as xlink:href to specify the href
        attribute in the XLink namespace. See namespaces for the map of supported namespaces;
        additional namespaces can be registered by adding to the map.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_attr>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value))))
        return select(content=f"{self.content}.attr({arguments})")


    def classed(self, names=None, value=None):
        """
        Source · If a value is specified, assigns or unassigns the specified CSS class names on
        the selected elements by setting the class attribute or modifying the classList
        property and returns this selection.
        .. code:: javascript

            selection.classed("foo", true)

        The specified names is a string of space-separated class names. For example, to assign
        the classes foo and bar to the selected elements:
        .. code:: javascript

            selection.classed("foo bar", true)

        If the value is truthy, then all elements are assigned the specified classes;
        otherwise, the classes are unassigned.
        .. code:: javascript

            selection.classed("foo", () => Math.random() > 0.5)

        If the value is a function, it is evaluated for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]). The function’s return value is then
        used to assign or unassign classes on each element.
        .. code:: javascript

            selection.classed("foo") // true, perhaps

        If a value is not specified, returns true if and only if the first (non-null) selected
        element has the specified classes. This is generally useful only if you know the
        selection contains exactly one element.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_classed>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (names, value))))
        return select(content=f"{self.content}.classed({arguments})")


    def style(self, name=None, value=None, priority=None):
        """
        Source · If a value is specified, sets the style property with the specified name to
        the specified value on the selected elements and returns this selection.
        .. code:: javascript

            selection.style("color", "red")

        If the value is a constant, then all elements are given the same style property value;
        otherwise, if the value is a function, it is evaluated for each selected element, in
        order, being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). The function’s return value
        is then used to set each element’s style property. A null value will remove the style
        property. An optional priority may also be specified, either as null or the string
        important (without the exclamation point).
        .. code:: javascript

            selection.style("color") // "red"

        If a value is not specified, returns the current value of the specified style property
        for the first (non-null) element in the selection. The current value is defined as the
        element’s inline value, if present, and otherwise its computed value. Accessing the
        current style value is generally useful only if you know the selection contains exactly
        one element.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_style>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value, priority))))
        return select(content=f"{self.content}.style({arguments})")


    def property(self, name=None, value=None):
        """
        Source · Some HTML elements have special properties that are not addressable using
        attributes or styles, such as a form field’s text value and a checkbox’s checked
        boolean. Use this method to get or set these properties.
        .. code:: javascript

            selection.property("checked", true)

        If a value is specified, sets the property with the specified name to the specified
        value on selected elements. If the value is a constant, then all elements are given the
        same property value; otherwise, if the value is a function, it is evaluated for each
        selected element, in order, being passed the current datum (d), the current index (i),
        and the current group (nodes), with this as the current DOM element (nodes[i]). The
        function’s return value is then used to set each element’s property. A null value will
        delete the specified property.
        .. code:: javascript

            selection.property("checked") // true, perhaps

        If a value is not specified, returns the value of the specified property for the first
        (non-null) element in the selection. This is generally useful only if you know the
        selection contains exactly one element.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_property>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, value))))
        return select(content=f"{self.content}.property({arguments})")


    def text(self, value=None):
        """
        Source · If a value is specified, sets the text content to the specified value on all
        selected elements, replacing any existing child elements.
        .. code:: javascript

            selection.text("Hello, world!")

        If the value is a constant, then all elements are given the same text content;
        otherwise, if the value is a function, it is evaluated for each selected element, in
        order, being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). The function’s return value
        is then used to set each element’s text content. A null value will clear the content.
        .. code:: javascript

            selection.text() // "Hello, world!"

        If a value is not specified, returns the text content for the first (non-null) element
        in the selection. This is generally useful only if you know the selection contains
        exactly one element.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_text>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return select(content=f"{self.content}.text({arguments})")


    def html(self, value=None):
        """
        Source · If a value is specified, sets the inner HTML to the specified value on all
        selected elements, replacing any existing child elements.
        .. code:: javascript

            selection.html("Hello, <i>world</i>!")

        If the value is a constant, then all elements are given the same inner HTML; otherwise,
        if the value is a function, it is evaluated for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]). The function’s return value is then
        used to set each element’s inner HTML. A null value will clear the content.
        .. code:: javascript

            selection.html() // "Hello, <i>world</i>!"

        If a value is not specified, returns the inner HTML for the first (non-null) element in
        the selection. This is generally useful only if you know the selection contains exactly
        one element.
        Use selection.append or selection.insert instead to create data-driven content; this
        method is intended for when you want a little bit of HTML, say for rich formatting.
        Also, selection.html is only supported on HTML elements. SVG elements and other
        non-HTML elements do not support the innerHTML property, and thus are incompatible with
        selection.html. Consider using XMLSerializer to convert a DOM subtree to text. See also
        the innersvg polyfill, which provides a shim to support the innerHTML property on SVG
        elements.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_html>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return select(content=f"{self.content}.html({arguments})")


    def append(self, type=None):
        """
        Source · If the specified type is a string, appends a new element of this type (tag
        name) as the last child of each selected element, or before the next following sibling
        in the update selection if this is an enter selection. The latter behavior for enter
        selections allows you to insert elements into the DOM in an order consistent with the
        new bound data; however, note that selection.order may still be required if updating
        elements change order (i.e., if the order of new data is inconsistent with old data).
        If the specified type is a function, it is evaluated for each selected element, in
        order, being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). This function should return
        an element to be appended. (The function typically creates a new element, but it may
        instead return an existing element.) For example, to append a paragraph to each DIV
        element:
        .. code:: javascript

            d3.selectAll("div").append("p");

        This is equivalent to:
        .. code:: javascript

            d3.selectAll("div").append(() => document.createElement("p"));

        Which is equivalent to:
        .. code:: javascript

            d3.selectAll("div").select(function() {
              return this.appendChild(document.createElement("p"));
            });

        In both cases, this method returns a new selection containing the appended elements.
        Each new element inherits the data of the current elements, if any, in the same manner
        as selection.select.
        The specified name may have a namespace prefix, such as svg:text to specify a text
        attribute in the SVG namespace. See namespaces for the map of supported namespaces;
        additional namespaces can be registered by adding to the map. If no namespace is
        specified, the namespace will be inherited from the parent element; or, if the name is
        one of the known prefixes, the corresponding namespace will be used (for example, svg
        implies svg:svg).

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_append>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (type,))))
        return select(content=f"{self.content}.append({arguments})")


    def insert(self, type=None, before=None):
        """
        Source · If the specified type is a string, inserts a new element of this type (tag
        name) before the first element matching the specified before selector for each selected
        element. For example, a before selector :first-child will prepend nodes before the
        first child. If before is not specified, it defaults to null. (To append elements in an
        order consistent with bound data, use selection.append.)
        Both type and before may instead be specified as functions which are evaluated for each
        selected element, in order, being passed the current datum (d), the current index (i),
        and the current group (nodes), with this as the current DOM element (nodes[i]). The
        type function should return an element to be inserted; the before function should
        return the child element before which the element should be inserted. For example, to
        append a paragraph to each DIV element:
        .. code:: javascript

            d3.selectAll("div").insert("p");

        This is equivalent to:
        .. code:: javascript

            d3.selectAll("div").insert(() => document.createElement("p"));

        Which is equivalent to:
        .. code:: javascript

            d3.selectAll("div").select(function() {
              return this.insertBefore(document.createElement("p"), null);
            });

        In both cases, this method returns a new selection containing the appended elements.
        Each new element inherits the data of the current elements, if any, in the same manner
        as selection.select.
        The specified name may have a namespace prefix, such as svg:text to specify a text
        attribute in the SVG namespace. See namespaces for the map of supported namespaces;
        additional namespaces can be registered by adding to the map. If no namespace is
        specified, the namespace will be inherited from the parent element; or, if the name is
        one of the known prefixes, the corresponding namespace will be used (for example, svg
        implies svg:svg).

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_insert>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (type, before))))
        return select(content=f"{self.content}.insert({arguments})")


    def remove(self):
        """
        Source · Removes the selected elements from the document. Returns this selection (the
        removed elements) which are now detached from the DOM. There is not currently a
        dedicated API to add removed elements back to the document; however, you can pass a
        function to selection.append or selection.insert to re-add elements.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_remove>`_.
        """
        return select(content=f"{self.content}.remove()")


    def clone(self, deep=None):
        """
        Source · Inserts clones of the selected elements immediately following the selected
        elements and returns a selection of the newly added clones. If deep is truthy, the
        descendant nodes of the selected elements will be cloned as well. Otherwise, only the
        elements themselves will be cloned. Equivalent to:
        .. code:: javascript

            selection.select(function() {
              return this.parentNode.insertBefore(this.cloneNode(deep), this.nextSibling);
            });


        See more informations `here <https://d3js.org/d3-selection/modifying#selection_clone>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (deep,))))
        return select(content=f"{self.content}.clone({arguments})")


    def sort(self, compare=None):
        """
        Source · Returns a new selection that contains a copy of each group in this selection
        sorted according to the compare function. After sorting, re-inserts elements to match
        the resulting order (per selection.order).
        The compare function, which defaults to ascending, is passed two elements’ data a and b
        to compare. It should return either a negative, positive, or zero value. If negative,
        then a should be before b; if positive, then a should be after b; otherwise, a and b
        are considered equal and the order is arbitrary.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_sort>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (compare,))))
        return select(content=f"{self.content}.sort({arguments})")


    def order(self):
        """
        Source · Re-inserts elements into the document such that the document order of each
        group matches the selection order. This is equivalent to calling selection.sort if the
        data is already sorted, but much faster.

        See more informations `here <https://d3js.org/d3-selection/modifying#selection_order>`_.
        """
        return select(content=f"{self.content}.order()")


    def raise_(self):
        """
        Source · Re-inserts each selected element, in order, as the last child of its parent.
        Equivalent to:
        .. code:: javascript

            selection.each(function() {
              this.parentNode.appendChild(this);
            });


        See more informations `here <https://d3js.org/d3-selection/modifying#selection_raise>`_.
        """
        return select(content=f"{self.content}.raise()")


    def lower(self):
        """
        Source · Re-inserts each selected element, in order, as the first child of its parent.
        Equivalent to:
        .. code:: javascript

            selection.each(function() {
              this.parentNode.insertBefore(this, this.parentNode.firstChild);
            });


        See more informations `here <https://d3js.org/d3-selection/modifying#selection_lower>`_.
        """
        return select(content=f"{self.content}.lower()")


    def data(self, data=None, key=None):
        """
        Source · Binds the specified array of data with the selected elements, returning a new
        selection that represents the update selection: the elements successfully bound to
        data. Also defines the enter and exit selections on the returned selection, which can
        be used to add or remove elements to correspond to the new data. The specified data is
        an array of arbitrary values (e.g., numbers or objects), or a function that returns an
        array of values for each group. When data is assigned to an element, it is stored in
        the property __data__, thus making the data “sticky” and available on re-selection.
        The data is specified for each group in the selection. If the selection has multiple
        groups (such as d3.selectAll followed by selection.selectAll), then data should
        typically be specified as a function. This function will be evaluated for each group in
        order, being passed the group’s parent datum (d, which may be undefined), the group
        index (i), and the selection’s parent nodes (nodes), with this as the group’s parent
        element.
        In conjunction with selection.join (or more explicitly with selection.enter,
        selection.exit, selection.append and selection.remove), selection.data can be used to
        enter, update and exit elements to match data. For example, to create an HTML table
        from a matrix of numbers:
        .. code:: javascript

            const matrix = [
              [11975,  5871, 8916, 2868],
              [ 1951, 10048, 2060, 6171],
              [ 8010, 16145, 8090, 8045],
              [ 1013,   990,  940, 6907]
            ];

            d3.select("body")
              .append("table")
              .selectAll("tr")
              .data(matrix)
              .join("tr")
              .selectAll("td")
              .data(d => d)
              .join("td")
                .text(d => d);

        In this example the data function is the identity function: for each table row, it
        returns the corresponding row from the data matrix.
        If a key function is not specified, then the first datum in data is assigned to the
        first selected element, the second datum to the second selected element, and so on. A
        key function may be specified to control which datum is assigned to which element,
        replacing the default join-by-index, by computing a string identifier for each datum
        and element. This key function is evaluated for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]); the returned string is the element’s
        key. The key function is then also evaluated for each new datum in data, being passed
        the current datum (d), the current index (i), and the group’s new data, with this as
        the group’s parent DOM element; the returned string is the datum’s key. The datum for a
        given key is assigned to the element with the matching key. If multiple elements have
        the same key, the duplicate elements are put into the exit selection; if multiple data
        have the same key, the duplicate data are put into the enter selection.
        For example, given this document:
        .. code:: javascript

            <div id="Ford"></div>
            <div id="Jarrah"></div>
            <div id="Kwon"></div>
            <div id="Locke"></div>
            <div id="Reyes"></div>
            <div id="Shephard"></div>

        You could join data by key as follows:
        .. code:: javascript

            const data = [
              {name: "Locke", number: 4},
              {name: "Reyes", number: 8},
              {name: "Ford", number: 15},
              {name: "Jarrah", number: 16},
              {name: "Shephard", number: 23},
              {name: "Kwon", number: 42}
            ];

            d3.selectAll("div")
              .data(data, function(d) { return d ? d.name : this.id; })
                .text(d => d.number);

        This example key function uses the datum d if present, and otherwise falls back to the
        element’s id property. Since these elements were not previously bound to data, the
        datum d is null when the key function is evaluated on selected elements, and non-null
        when the key function is evaluated on the new data.
        The update and enter selections are returned in data order, while the exit selection
        preserves the selection order prior to the join. If a key function is specified, the
        order of elements in the selection may not match their order in the document; use
        selection.order or selection.sort as needed. For more on how the key function affects
        the join, see A Bar Chart, Part 2 and Object Constancy.
        If data is not specified, this method returns the array of data for the selected
        elements.
        This method cannot be used to clear bound data; use selection.datum instead.

        See more informations `here <https://d3js.org/d3-selection/joining#selection_data>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data, key))))
        return select(content=f"{self.content}.data({arguments})")


    def join(self, enter=None, update=None, exit=None):
        """
        Source · Appends, removes and reorders elements as necessary to match the data that was
        previously bound by selection.data, returning the merged enter and update selection.
        This method is a convenient alternative to the explicit general update pattern,
        replacing selection.enter, selection.exit, selection.append, selection.remove, and
        selection.order. For example:
        .. code:: javascript

            svg.selectAll("circle")
              .data(data)
              .join("circle")
                .attr("fill", "none")
                .attr("stroke", "black");

        The enter function may be specified as a string shorthand, as above, which is
        equivalent to selection.append with the given element name. Likewise, optional update
        and exit functions may be specified, which default to the identity function and calling
        selection.remove, respectively. The shorthand above is thus equivalent to:
        .. code:: javascript

            svg.selectAll("circle")
              .data(data)
              .join(
                enter => enter.append("circle"),
                update => update,
                exit => exit.remove()
              )
                .attr("fill", "none")
                .attr("stroke", "black");

        By passing separate functions on enter, update and exit, you have greater control over
        what happens. And by specifying a key function to selection.data, you can minimize
        changes to the DOM to optimize performance. For example, to set different fill colors
        for enter and update:
        .. code:: javascript

            svg.selectAll("circle")
              .data(data)
              .join(
                enter => enter.append("circle").attr("fill", "green"),
                update => update.attr("fill", "blue")
              )
                .attr("stroke", "black");

        The selections returned by the enter and update functions are merged and then returned
        by selection.join.
        You can animate enter, update and exit by creating transitions inside the enter, update
        and exit functions. If the enter and update functions return transitions, their
        underlying selections are merged and then returned by selection.join. The return value
        of the exit function is not used.
        For more, see the selection.join notebook.

        See more informations `here <https://d3js.org/d3-selection/joining#selection_join>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (enter, update, exit))))
        return select(content=f"{self.content}.join({arguments})")


    def enter(self):
        """
        Source · Returns the enter selection: placeholder nodes for each datum that had no
        corresponding DOM element in the selection. (The enter selection is empty for
        selections not returned by selection.data.)
        The enter selection is typically used to create “missing” elements corresponding to new
        data. For example, to create DIV elements from an array of numbers:
        .. code:: javascript

            const div = d3.select("body")
              .selectAll("div")
              .data([4, 8, 15, 16, 23, 42])
              .enter().append("div")
                .text(d => d);

        If the body is initially empty, the above code will create six new DIV elements, append
        them to the body in-order, and assign their text content as the associated
        (string-coerced) number:
        .. code:: javascript

            <div>4</div>
            <div>8</div>
            <div>15</div>
            <div>16</div>
            <div>23</div>
            <div>42</div>

        Conceptually, the enter selection’s placeholders are pointers to the parent element (in
        this example, the document body). The enter selection is typically only used
        transiently to append elements, and is often merged with the update selection after
        appending, such that modifications can be applied to both entering and updating
        elements.

        See more informations `here <https://d3js.org/d3-selection/joining#selection_enter>`_.
        """
        return select(content=f"{self.content}.enter()")


    def exit(self):
        """
        Source · Returns the exit selection: existing DOM elements in the selection for which
        no new datum was found. (The exit selection is empty for selections not returned by
        selection.data.)
        The exit selection is typically used to remove “superfluous” elements corresponding to
        old data. For example, to update the DIV elements created previously with a new array
        of numbers:
        .. code:: javascript

            div = div.data([1, 2, 4, 8, 16, 32], d => d);

        Since a key function was specified (as the identity function), and the new data
        contains the numbers [4, 8, 16] which match existing elements in the document, the
        update selection contains three DIV elements. Leaving those elements as-is, we can
        append new elements for [1, 2, 32] using the enter selection:
        .. code:: javascript

            div.enter().append("div").text(d => d);

        Likewise, to remove the exiting elements [15, 23, 42]:
        .. code:: javascript

            div.exit().remove();

        Now the document body looks like this:
        .. code:: javascript

            <div>1</div>
            <div>2</div>
            <div>4</div>
            <div>8</div>
            <div>16</div>
            <div>32</div>

        The order of the DOM elements matches the order of the data because the old data’s
        order and the new data’s order were consistent. If the new data’s order is different,
        use selection.order to reorder the elements in the DOM. See the general update pattern
        notebook for more on data joins.

        See more informations `here <https://d3js.org/d3-selection/joining#selection_exit>`_.
        """
        return select(content=f"{self.content}.exit()")


    def datum(self, value=None):
        """
        Source · Gets or sets the bound data for each selected element. Unlike selection.data,
        this method does not compute a join and does not affect indexes or the enter and exit
        selections.
        If a value is specified, sets the element’s bound data to the specified value on all
        selected elements. If the value is a constant, all elements are given the same datum;
        otherwise, if the value is a function, it is evaluated for each selected element, in
        order, being passed the current datum (d), the current index (i), and the current group
        (nodes), with this as the current DOM element (nodes[i]). The function is then used to
        set each element’s new data. A null value will delete the bound data.
        If a value is not specified, returns the bound datum for the first (non-null) element
        in the selection. This is generally useful only if you know the selection contains
        exactly one element.
        This method is useful for accessing HTML5 custom data attributes. For example, given
        the following elements:
        .. code:: javascript

            <ul id="list">
              <li data-username="shawnbot">Shawn Allen</li>
              <li data-username="mbostock">Mike Bostock</li>
            </ul>

        You can expose the custom data attributes by setting each element’s data as the
        built-in dataset property:
        .. code:: javascript

            selection.datum(function() { return this.dataset; })


        See more informations `here <https://d3js.org/d3-selection/joining#selection_datum>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return select(content=f"{self.content}.datum({arguments})")


    def on(self, typenames=None, listener=None, options=None):
        """
        Source · Adds or removes a listener to each selected element for the specified event
        typenames.
        .. code:: javascript

            d3.selectAll("p").on("click", (event) => console.log(event))

        The typenames is a string event type, such as click, mouseover, or submit; any DOM
        event type supported by your browser may be used. The type may be optionally followed
        by a period (.) and a name; the optional name allows multiple callbacks to be
        registered to receive events of the same type, such as click.foo and click.bar. To
        specify multiple typenames, separate typenames with spaces, such as input change or
        click.foo click.bar.
        When a specified event is dispatched on a selected element, the specified listener will
        be evaluated for the element, being passed the current event (event) and the current
        datum (d), with this as the current DOM element (event.currentTarget). Listeners always
        see the latest datum for their element. Note: while you can use event.pageX and
        event.pageY directly, it is often convenient to transform the event position to the
        local coordinate system of the element that received the event using d3.pointer.
        If an event listener was previously registered for the same typename on a selected
        element, the old listener is removed before the new listener is added. To remove a
        listener, pass null as the listener. To remove all listeners for a given name, pass
        null as the listener and .foo as the typename, where foo is the name; to remove all
        listeners with no name, specify . as the typename.
        An optional options object may specify characteristics about the event listener, such
        as whether it is capturing or passive; see element.addEventListener.
        If a listener is not specified, returns the currently-assigned listener for the
        specified event typename on the first (non-null) selected element, if any. If multiple
        typenames are specified, the first matching listener is returned.

        See more informations `here <https://d3js.org/d3-selection/events#selection_on>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (typenames, listener, options))))
        return select(content=f"{self.content}.on({arguments})")


    def dispatch(self, type=None, parameters=None):
        """
        Source · Dispatches a custom event of the specified type to each selected element, in
        order.
        .. code:: javascript

            d3.select("p").dispatch("click")

        An optional parameters object may be specified to set additional properties of the
        event. It may contain the following fields:
        If parameters is a function, it is evaluated for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]). It must return the parameters for the
        current element.

        See more informations `here <https://d3js.org/d3-selection/events#selection_dispatch>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (type, parameters))))
        return select(content=f"{self.content}.dispatch({arguments})")


    def each(self, function=None):
        """
        Source · Invokes the specified function for each selected element, in order, being
        passed the current datum (d), the current index (i), and the current group (nodes),
        with this as the current DOM element (nodes[i]). This method can be used to invoke
        arbitrary code for each selected element, and is useful for creating a context to
        access parent and child data simultaneously, such as:
        .. code:: javascript

            parent.each(function(p, j) {
              d3.select(this)
                .selectAll(".child")
                  .text(d => `child ${d.name} of ${p.name}`);
            });

        See sized donut multiples for an example.

        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_each>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function,))))
        return select(content=f"{self.content}.each({arguments})")


    def call(self, function=None, *arguments):
        """
        Source · Invokes the specified function exactly once, passing in this selection along
        with any optional arguments. Returns this selection. This is equivalent to invoking the
        function by hand but facilitates method chaining. For example, to set several styles in
        a reusable function:
        .. code:: javascript

            function name(selection, first, last) {
              selection
                  .attr("first-name", first)
                  .attr("last-name", last);
            }

        Now say:
        .. code:: javascript

            d3.selectAll("div").call(name, "John", "Snow");

        This is roughly equivalent to:
        .. code:: javascript

            name(d3.selectAll("div"), "John", "Snow");

        The only difference is that selection.call always returns the selection and not the
        return value of the called function, name.

        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_call>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function, *arguments))))
        return select(content=f"{self.content}.call({arguments})")


    def empty(self):
        """
        Source · Returns true if this selection contains no (non-null) elements.
        .. code:: javascript

            d3.selectAll("p").empty() // false, here


        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_empty>`_.
        """
        return select(content=f"{self.content}.empty()")


    def nodes(self):
        """
        Source · Returns an array of all (non-null) elements in this selection.
        .. code:: javascript

            d3.selectAll("p").nodes() // [p, p, p, …]

        Equivalent to:
        .. code:: javascript

            Array.from(selection)


        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_nodes>`_.
        """
        return select(content=f"{self.content}.nodes()")


    def node(self):
        """
        Source · Returns the first (non-null) element in this selection. If the selection is
        empty, returns null.

        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_node>`_.
        """
        return select(content=f"{self.content}.node()")


    def size(self):
        """
        Source · Returns the total number of (non-null) elements in this selection.

        See more informations `here <https://d3js.org/d3-selection/control-flow#selection_size>`_.
        """
        return select(content=f"{self.content}.size()")


    def transition(self, name=None):
        """
        Source · Returns a new transition on the given selection with the specified name. If a
        name is not specified, null is used. The new transition is only exclusive with other
        transitions of the same name.
        If the name is a transition instance, the returned transition has the same id and name
        as the specified transition. If a transition with the same id already exists on a
        selected element, the existing transition is returned for that element. Otherwise, the
        timing of the returned transition is inherited from the existing transition of the same
        id on the nearest ancestor of each selected element. Thus, this method can be used to
        synchronize a transition across multiple selections, or to re-select a transition for
        specific elements and modify its configuration. For example:
        .. code:: javascript

            const t = d3.transition()
                .duration(750)
                .ease(d3.easeLinear);

            d3.selectAll(".apple").transition(t)
                .style("fill", "red");

            d3.selectAll(".orange").transition(t)
                .style("fill", "orange");

        If the specified transition is not found on a selected node or its ancestors (such as
        if the transition already ended), the default timing parameters are used; however, in a
        future release, this will likely be changed to throw an error. See #59.

        See more informations `here <https://d3js.org/d3-transition/selecting#selection_transition>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name,))))
        return select(content=f"{self.content}.transition({arguments})")


    def interrupt(self, name=None):
        """
        Source · Interrupts the active transition of the specified name on the selected
        elements, and cancels any pending transitions with the specified name, if any. If a
        name is not specified, null is used.
        Interrupting a transition on an element has no effect on any transitions on any
        descendant elements. For example, an axis transition consists of multiple independent,
        synchronized transitions on the descendants of the axis G element (the tick lines, the
        tick labels, the domain path, etc.). To interrupt the axis transition, you must
        therefore interrupt the descendants:
        .. code:: javascript

            selection.selectAll("*").interrupt();

        The universal selector, *, selects all descendant elements. If you also want to
        interrupt the G element itself:
        .. code:: javascript

            selection.interrupt().selectAll("*").interrupt();


        See more informations `here <https://d3js.org/d3-transition/control-flow#selection_interrupt>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name,))))
        return select(content=f"{self.content}.interrupt({arguments})")

