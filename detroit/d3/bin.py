# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class _bin:
    def __init__(self, content="bin"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def value(self, value=None):
        """
        .. code:: javascript

            const bin = d3.bin().value((d) => d.culmen_length_mm);

        If value is specified, sets the value accessor to the specified function or constant
        and returns this bin generator.
        .. code:: javascript

            bin.value() // (d) => d.culmen_length_mm

        If value is not specified, returns the current value accessor, which defaults to the
        identity function.
        When bins are generated, the value accessor will be invoked for each element in the
        input data array, being passed the element d, the index i, and the array data as three
        arguments. The default value accessor assumes that the input data are orderable
        (comparable), such as numbers or dates. If your data are not, then you should specify
        an accessor that returns the corresponding orderable value for a given datum.
        This is similar to mapping your data to values before invoking the bin generator, but
        has the benefit that the input data remains associated with the returned bins, thereby
        making it easier to access other fields of the data.

        See more informations `here <https://d3js.org/d3-array/bin#bin_value>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return bin(content=f"{self.content}.value({arguments})")


    def domain(self, domain=None):
        """
        .. code:: javascript

            const bin = d3.bin().domain([0, 1]);

        If domain is specified, sets the domain accessor to the specified function or array and
        returns this bin generator.
        .. code:: javascript

            bin.domain() // [0, 1]

        If domain is not specified, returns the current domain accessor, which defaults to
        extent. The bin domain is defined as an array [min, max], where min is the minimum
        observable value and max is the maximum observable value; both values are inclusive.
        Any value outside of this domain will be ignored when the bins are generated.
        For example, to use a bin generator with a linear scale x, you might say:
        .. code:: javascript

            const bin = d3.bin().domain(x.domain()).thresholds(x.ticks(20));

        You can then compute the bins from an array of numbers like so:
        .. code:: javascript

            const bins = bin(numbers);

        If the default extent domain is used and the thresholds are specified as a count
        (rather than explicit values), then the computed domain will be niced such that all
        bins are uniform width.
        Note that the domain accessor is invoked on the materialized array of values, not on
        the input data array.

        See more informations `here <https://d3js.org/d3-array/bin#bin_domain>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (domain,))))
        return bin(content=f"{self.content}.domain({arguments})")


    def thresholds(self, thresholds=None):
        """
        .. code:: javascript

            const bin = d3.bin().thresholds(20);

        If thresholds is specified as a number, then the domain will be uniformly divided into
        approximately that many bins; see ticks.
        .. code:: javascript

            const bin = d3.bin().thresholds([0.25, 0.5, 0.75]);

        If thresholds is specified as an array, sets the thresholds to the specified values and
        returns this bin generator. Thresholds are defined as an array of values [x0, x1, …].
        Any value less than x0 will be placed in the first bin; any value greater than or equal
        to x0 but less than x1 will be placed in the second bin; and so on. Thus, the generated
        bins will have thresholds.length + 1 bins. Any threshold values outside the domain are
        ignored. The first bin.x0 is always equal to the minimum domain value, and the last
        bin.x1 is always equal to the maximum domain value.
        .. code:: javascript

            const bin = d3.bin().thresholds((values) => [d3.median(values)]);

        If thresholds is specified as a function, the function will be passed three arguments:
        the array of input values derived from the data, and the domain represented as min and
        max. The function may then return either the array of numeric thresholds or the count
        of bins; in the latter case the domain is divided uniformly into approximately count
        bins; see ticks. For instance, you might want to use time ticks when binning
        time-series data; see example.
        .. code:: javascript

            bin.thresholds() // () => [0, 0.5, 1]

        If thresholds is not specified, returns the current threshold generator, which by
        default implements Sturges’ formula. (Thus by default, the values to be binned must be
        numbers!)

        See more informations `here <https://d3js.org/d3-array/bin#bin_thresholds>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (thresholds,))))
        return bin(content=f"{self.content}.thresholds({arguments})")

