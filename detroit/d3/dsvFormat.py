# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class dsvFormat:
    def __init__(self, content="dsvFormat"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def parse(self, string=None, row=None):
        """
        .. code:: javascript

            d3.csvParse("foo,bar\n1,2") // [{foo: "1", bar: "2"}, columns: ["foo", "bar"]]

        Source · Parses the specified string, which must be in the delimiter-separated values
        format with the appropriate delimiter, returning an array of objects representing the
        parsed rows.
        Unlike dsv.parseRows, this method requires that the first line of the DSV content
        contains a delimiter-separated list of column names; these column names become the
        attributes on the returned objects. For example, consider the following CSV file:
        .. code:: javascript

            Year,Make,Model,Length
            1997,Ford,E350,2.34
            2000,Mercury,Cougar,2.38

        The resulting JavaScript array is:
        .. code:: javascript

            [
              {"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"},
              {"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"}
            ]

        The returned array also exposes a columns property containing the column names in input
        order (in contrast to Object.keys, whose iteration order is arbitrary). For example:
        .. code:: javascript

            data.columns // ["Year", "Make", "Model", "Length"]

        If the column names are not unique, only the last value is returned for each name; to
        access all values, use dsv.parseRows instead (see example).
        If a row conversion function is not specified, field values are strings. For safety,
        there is no automatic conversion to numbers, dates, or other types. In some cases,
        JavaScript may coerce strings to numbers for you automatically (for example, using the
        + operator), but better is to specify a row conversion function. See d3.autoType for a
        convenient row conversion function that infers and coerces common types like numbers
        and strings.
        If a row conversion function is specified, the specified function is invoked for each
        row, being passed an object representing the current row (d), the index (i) starting at
        zero for the first non-header row, and the array of column names. If the returned value
        is null or undefined, the row is skipped and will be omitted from the array returned by
        dsv.parse; otherwise, the returned value defines the corresponding row object. For
        example:
        .. code:: javascript

            const data = d3.csvParse(string, (d) => {
              return {
                year: new Date(+d.Year, 0, 1), // lowercase and convert "Year" to Date
                make: d.Make, // lowercase
                model: d.Model, // lowercase
                length: +d.Length // lowercase and convert "Length" to number
              };
            });

        Note: using + or Number rather than parseInt or parseFloat is typically faster, though
        more restrictive. For example, "30px" when coerced using + returns NaN, while parseInt
        and parseFloat return 30.

        See more informations `here <https://d3js.org/d3-dsv#dsv_parse>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (string, row))))
        return dsvFormat(content=f"{self.content}.parse({arguments})")


    def parseRows(self, string=None, row=None):
        """
        .. code:: javascript

            d3.csvParseRows("foo,bar\n1,2") // [["foo", "bar"], ["1", "2"]]

        Source · Parses the specified string, which must be in the delimiter-separated values
        format with the appropriate delimiter, returning an array of arrays representing the
        parsed rows.
        Unlike dsv.parse, this method treats the header line as a standard row, and should be
        used whenever DSV content does not contain a header. Each row is represented as an
        array rather than an object. Rows may have variable length. For example, consider the
        following CSV file, which notably lacks a header line:
        .. code:: javascript

            1997,Ford,E350,2.34
            2000,Mercury,Cougar,2.38

        The resulting JavaScript array is:
        .. code:: javascript

            [
              ["1997", "Ford", "E350", "2.34"],
              ["2000", "Mercury", "Cougar", "2.38"]
            ]

        If a row conversion function is not specified, field values are strings. For safety,
        there is no automatic conversion to numbers, dates, or other types. In some cases,
        JavaScript may coerce strings to numbers for you automatically (for example, using the
        + operator), but better is to specify a row conversion function. See d3.autoType for a
        convenient row conversion function that infers and coerces common types like numbers
        and strings.
        If a row conversion function is specified, the specified function is invoked for each
        row, being passed an array representing the current row (d), the index (i) starting at
        zero for the first row, and the array of column names. If the returned value is null or
        undefined, the row is skipped and will be omitted from the array returned by dsv.parse;
        otherwise, the returned value defines the corresponding row object. For example:
        .. code:: javascript

            const data = d3.csvParseRows(string, (d, i) => {
              return {
                year: new Date(+d[0], 0, 1), // convert first column to Date
                make: d[1],
                model: d[2],
                length: +d[3] // convert fourth column to number
              };
            });

        In effect, row is similar to applying a map and filter operator to the returned rows.

        See more informations `here <https://d3js.org/d3-dsv#dsv_parseRows>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (string, row))))
        return dsvFormat(content=f"{self.content}.parseRows({arguments})")


    def format(self, rows=None, columns=None):
        """
        .. code:: javascript

            d3.csvFormat([{foo: "1", bar: "2"}]) // "foo,bar\n1,2"

        .. code:: javascript

            d3.csvFormat([{foo: "1", bar: "2"}], ["foo"]) // "foo\n1"

        Source · Formats the specified array of object rows as delimiter-separated values,
        returning a string. This operation is the inverse of dsv.parse. Each row will be
        separated by a newline (\n), and each column within each row will be separated by the
        delimiter (such as a comma, ,). Values that contain either the delimiter, a
        double-quote (") or a newline will be escaped using double-quotes.
        If columns is not specified, the list of column names that forms the header row is
        determined by the union of all properties on all objects in rows; the order of columns
        is nondeterministic. If columns is specified, it is an array of strings representing
        the column names. For example:
        .. code:: javascript

            const string = d3.csvFormat(data, ["year", "make", "model", "length"]);

        All fields on each row object will be coerced to strings. If the field value is null or
        undefined, the empty string is used. If the field value is a Date, the ECMAScript
        date-time string format (a subset of ISO 8601) is used: for example, dates at UTC
        midnight are formatted as YYYY-MM-DD. For more control over which and how fields are
        formatted, first map rows to an array of array of string, and then use dsv.formatRows.

        See more informations `here <https://d3js.org/d3-dsv#dsv_format>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (rows, columns))))
        return dsvFormat(content=f"{self.content}.format({arguments})")


    def formatBody(self, rows=None, columns=None):
        """
        .. code:: javascript

            d3.csvFormatBody([{foo: "1", bar: "2"}]) // "1,2"

        .. code:: javascript

            d3.csvFormatBody([{foo: "1", bar: "2"}], ["foo"]) // "1"

        Source · Equivalent to dsv.format, but omits the header row. This is useful, for
        example, when appending rows to an existing file.

        See more informations `here <https://d3js.org/d3-dsv#dsv_formatBody>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (rows, columns))))
        return dsvFormat(content=f"{self.content}.formatBody({arguments})")


    def formatRows(self, rows=None):
        """
        .. code:: javascript

            d3.csvFormatRows([["foo", "bar"], ["1", "2"]]) // "foo,bar\n1,2"

        Source · Formats the specified array of array of string rows as delimiter-separated
        values, returning a string. This operation is the reverse of dsv.parseRows. Each row
        will be separated by a newline (\n), and each column within each row will be separated
        by the delimiter (such as a comma, ,). Values that contain either the delimiter, a
        double-quote (") or a newline will be escaped using double-quotes.
        To convert an array of objects to an array of arrays while explicitly specifying the
        columns, use array.map. For example:
        .. code:: javascript

            const string = d3.csvFormatRows(data.map((d, i) => {
              return [
                d.year.getUTCFullYear(), // Assuming d.year is a Date object.
                d.make,
                d.model,
                d.length
              ];
            }));

        If you like, you can also array.concat this result with an array of column names to
        generate the first row:
        .. code:: javascript

            const string = d3.csvFormatRows([[
                "year",
                "make",
                "model",
                "length"
              ]].concat(data.map((d, i) => {
              return [
                d.year.getUTCFullYear(), // Assuming d.year is a Date object.
                d.make,
                d.model,
                d.length
              ];
            })));


        See more informations `here <https://d3js.org/d3-dsv#dsv_formatRows>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (rows,))))
        return dsvFormat(content=f"{self.content}.formatRows({arguments})")


    def formatRow(self, row=None):
        """
        .. code:: javascript

            d3.csvFormatRow(["foo", "bar"]) // "foo,bar"

        Source · Formats a single array row of strings as delimiter-separated values, returning
        a string. Each column within the row will be separated by the delimiter (such as a
        comma, ,). Values that contain either the delimiter, a double-quote (") or a newline
        will be escaped using double-quotes.

        See more informations `here <https://d3js.org/d3-dsv#dsv_formatRow>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (row,))))
        return dsvFormat(content=f"{self.content}.formatRow({arguments})")


    def formatValue(self, value=None):
        """
        .. code:: javascript

            d3.csvFormatValue("foo") // "foo"

        Source · Format a single value or string as a delimiter-separated value, returning a
        string. A value that contains either the delimiter, a double-quote (") or a newline
        will be escaped using double-quotes.

        See more informations `here <https://d3js.org/d3-dsv#dsv_formatValue>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return dsvFormat(content=f"{self.content}.formatValue({arguments})")

