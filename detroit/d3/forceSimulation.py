# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class forceSimulation:
    def __init__(self, content="forceSimulation"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def restart(self):
        """
        Source · Restarts the simulation’s internal timer and returns the simulation. In
        conjunction with simulation.alphaTarget or simulation.alpha, this method can be used to
        “reheat” the simulation during interaction, such as when dragging a node, or to resume
        the simulation after temporarily pausing it with simulation.stop.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_restart>`_.
        """
        return forceSimulation(content=f"{self.content}.restart()")


    def stop(self):
        """
        Source · Stops the simulation’s internal timer, if it is running, and returns the
        simulation. If the timer is already stopped, this method does nothing. This method is
        useful for running the simulation manually; see simulation.tick.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_stop>`_.
        """
        return forceSimulation(content=f"{self.content}.stop()")


    def tick(self, iterations=None):
        """
        Source · Manually steps the simulation by the specified number of iterations, and
        returns the simulation. If iterations is not specified, it defaults to 1 (single step).
        For each iteration, it increments the current alpha by (alphaTarget - alpha) ×
        alphaDecay; then invokes each registered force, passing the new alpha; then decrements
        each node’s velocity by velocity × velocityDecay; lastly increments each node’s
        position by velocity.
        This method does not dispatch events; events are only dispatched by the internal timer
        when the simulation is started automatically upon creation or by calling
        simulation.restart. The natural number of ticks when the simulation is started is
        ⌈log(alphaMin) / log(1 - alphaDecay)⌉; by default, this is 300.
        This method can be used in conjunction with simulation.stop to compute a static force
        layout. For large graphs, static layouts should be computed in a web worker to avoid
        freezing the user interface.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_tick>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (iterations,))))
        return forceSimulation(content=f"{self.content}.tick({arguments})")


    def nodes(self, nodes=None):
        """
        Source · If nodes is specified, sets the simulation’s nodes to the specified array of
        objects, initializing their positions and velocities if necessary, and then
        re-initializes any bound forces; returns the simulation. If nodes is not specified,
        returns the simulation’s array of nodes as specified to the constructor.
        Each node must be an object. The following properties are assigned by the simulation:
        The position ⟨x,y⟩ and velocity ⟨vx,vy⟩ may be subsequently modified by forces and by
        the simulation. If either vx or vy is NaN, the velocity is initialized to ⟨0,0⟩. If
        either x or y is NaN, the position is initialized in a phyllotaxis arrangement, so
        chosen to ensure a deterministic, uniform distribution.
        To fix a node in a given position, you may specify two additional properties:
        At the end of each tick, after the application of any forces, a node with a defined
        node.fx has node.x reset to this value and node.vx set to zero; likewise, a node with a
        defined node.fy has node.y reset to this value and node.vy set to zero. To unfix a node
        that was previously fixed, set node.fx and node.fy to null, or delete these properties.
        If the specified array of nodes is modified, such as when nodes are added to or removed
        from the simulation, this method must be called again with the new (or changed) array
        to notify the simulation and bound forces of the change; the simulation does not make a
        defensive copy of the specified array.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_nodes>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (nodes,))))
        return forceSimulation(content=f"{self.content}.nodes({arguments})")


    def alpha(self, alpha=None):
        """
        Source · alpha is roughly analogous to temperature in simulated annealing. It decreases
        over time as the simulation “cools down”. When alpha reaches alphaMin, the simulation
        stops; see simulation.restart.
        If alpha is specified, sets the current alpha to the specified number in the range
        [0,1] and returns this simulation. If alpha is not specified, returns the current alpha
        value, which defaults to 1.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_alpha>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (alpha,))))
        return forceSimulation(content=f"{self.content}.alpha({arguments})")


    def alphaMin(self, min=None):
        """
        Source · If min is specified, sets the minimum alpha to the specified number in the
        range [0,1] and returns this simulation. If min is not specified, returns the current
        minimum alpha value, which defaults to 0.001. The simulation’s internal timer stops
        when the current alpha is less than the minimum alpha. The default alpha decay rate of
        ~0.0228 corresponds to 300 iterations.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_alphaMin>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (min,))))
        return forceSimulation(content=f"{self.content}.alphaMin({arguments})")


    def alphaDecay(self, decay=None):
        """
        Source · If decay is specified, sets the alpha decay rate to the specified number in
        the range [0,1] and returns this simulation. If decay is not specified, returns the
        current alpha decay rate, which defaults to 0.0228… = 1 - pow(0.001, 1 / 300) where
        0.001 is the default minimum alpha.
        The alpha decay rate determines how quickly the current alpha interpolates towards the
        desired target alpha; since the default target alpha is zero, by default this controls
        how quickly the simulation cools. Higher decay rates cause the simulation to stabilize
        more quickly, but risk getting stuck in a local minimum; lower values cause the
        simulation to take longer to run, but typically converge on a better layout. To have
        the simulation run forever at the current alpha, set the decay rate to zero;
        alternatively, set a target alpha greater than the minimum alpha.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_alphaDecay>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (decay,))))
        return forceSimulation(content=f"{self.content}.alphaDecay({arguments})")


    def alphaTarget(self, target=None):
        """
        Source · If target is specified, sets the current target alpha to the specified number
        in the range [0,1] and returns this simulation. If target is not specified, returns the
        current target alpha value, which defaults to 0.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_alphaTarget>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (target,))))
        return forceSimulation(content=f"{self.content}.alphaTarget({arguments})")


    def velocityDecay(self, decay=None):
        """
        Source · If decay is specified, sets the velocity decay factor to the specified number
        in the range [0,1] and returns this simulation. If decay is not specified, returns the
        current velocity decay factor, which defaults to 0.4. The decay factor is akin to
        atmospheric friction; after the application of any forces during a tick, each node’s
        velocity is multiplied by 1 - decay. As with lowering the alpha decay rate, less
        velocity decay may converge on a better solution, but risks numerical instabilities and
        oscillation.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_velocityDecay>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (decay,))))
        return forceSimulation(content=f"{self.content}.velocityDecay({arguments})")


    def force(self, name=None, force=None):
        """
        Source · If force is specified, assigns the force for the specified name and returns
        this simulation. If force is not specified, returns the force with the specified name,
        or undefined if there is no such force. (By default, new simulations have no forces.)
        For example, to create a new simulation to layout a graph, you might say:
        .. code:: javascript

            const simulation = d3.forceSimulation(nodes)
                .force("charge", d3.forceManyBody())
                .force("link", d3.forceLink(links))
                .force("center", d3.forceCenter());

        To remove the force with the given name, pass null as the force. For example, to remove
        the charge force:
        .. code:: javascript

            simulation.force("charge", null);


        See more informations `here <https://d3js.org/d3-force/simulation#simulation_force>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (name, force))))
        return forceSimulation(content=f"{self.content}.force({arguments})")


    def find(self, x=None, y=None, radius=None):
        """
        Source · Returns the node closest to the position ⟨x,y⟩ with the given search radius.
        If radius is not specified, it defaults to infinity. If there is no node within the
        search area, returns undefined.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_find>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (x, y, radius))))
        return forceSimulation(content=f"{self.content}.find({arguments})")


    def randomSource(self, source=None):
        """
        Source)
        If source is specified, sets the function used to generate random numbers; this should
        be a function that returns a number between 0 (inclusive) and 1 (exclusive). If source
        is not specified, returns this simulation’s current random source which defaults to a
        fixed-seed linear congruential generator. See also random.source.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_randomSource>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (source,))))
        return forceSimulation(content=f"{self.content}.randomSource({arguments})")


    def on(self, typenames=None, listener=None):
        """
        Source · If listener is specified, sets the event listener for the specified typenames
        and returns this simulation. If an event listener was already registered for the same
        type and name, the existing listener is removed before the new listener is added. If
        listener is null, removes the current event listeners for the specified typenames, if
        any. If listener is not specified, returns the first currently-assigned listener
        matching the specified typenames, if any. When a specified event is dispatched, each
        listener will be invoked with the this context as the simulation.
        The typenames is a string containing one or more typename separated by whitespace. Each
        typename is a type, optionally followed by a period (.) and a name, such as tick.foo
        and tick.bar; the name allows multiple listeners to be registered for the same type.
        The type must be one of the following:
        Note that tick events are not dispatched when simulation.tick is called manually;
        events are only dispatched by the internal timer and are intended for interactive
        rendering of the simulation. To affect the simulation, register forces instead of
        modifying nodes’ positions or velocities inside a tick event listener.
        See dispatch.on for details.

        See more informations `here <https://d3js.org/d3-force/simulation#simulation_on>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (typenames, listener))))
        return forceSimulation(content=f"{self.content}.on({arguments})")


    def initialize(self, nodes=None):
        """
        Supplies the array of nodes and random source to this force. This method is called when
        a force is bound to a simulation via simulation.force and when the simulation’s nodes
        change via simulation.nodes. A force may perform necessary work during initialization,
        such as evaluating per-node parameters, to avoid repeatedly performing work during each
        application of the force.

        See more informations `here <https://d3js.org/d3-force/simulation#force_initialize>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (nodes,))))
        return forceSimulation(content=f"{self.content}.initialize({arguments})")

