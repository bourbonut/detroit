# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class forceLink:
    def __init__(self, content="forceLink"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def links(self, links=None):
        """
        Source · If links is specified, sets the array of links associated with this force,
        recomputes the distance and strength parameters for each link, and returns this force.
        If links is not specified, returns the current array of links, which defaults to the
        empty array.
        Each link is an object with the following properties:
        For convenience, a link’s source and target properties may be initialized using numeric
        or string identifiers rather than object references; see link.id.
        If the specified array of links is modified, such as when links are added to or removed
        from the simulation, this method must be called again with the new (or changed) array
        to notify the force of the change; the force does not make a defensive copy of the
        specified array.

        See more informations `here <https://d3js.org/d3-force/link#link_links>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (links,))))
        return forceLink(content=f"{self.content}.links({arguments})")


    def id(self, id=None):
        """
        Source · If id is specified, sets the node id accessor to the specified function and
        returns this force. If id is not specified, returns the current node id accessor, which
        defaults to the numeric node.index:
        .. code:: javascript

            function id(d) {
              return d.index;
            }

        The default id accessor allows each link’s source and target to be specified as a
        zero-based index into the nodes array. For example:
        .. code:: javascript

            const nodes = [
              {"id": "Alice"},
              {"id": "Bob"},
              {"id": "Carol"}
            ];

            const links = [
              {"source": 0, "target": 1}, // Alice → Bob
              {"source": 1, "target": 2} // Bob → Carol
            ];

        Now consider a different id accessor that returns a string:
        .. code:: javascript

            function id(d) {
              return d.id;
            }

        With this accessor, you can use named sources and targets:
        .. code:: javascript

            const nodes = [
              {"id": "Alice"},
              {"id": "Bob"},
              {"id": "Carol"}
            ];

            const links = [
              {"source": "Alice", "target": "Bob"},
              {"source": "Bob", "target": "Carol"}
            ];

        This is particularly useful when representing graphs in JSON, as JSON does not allow
        references. See this example.
        The id accessor is invoked for each node whenever the force is initialized, as when the
        nodes or links change, being passed the node and its zero-based index.

        See more informations `here <https://d3js.org/d3-force/link#link_id>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (id,))))
        return forceLink(content=f"{self.content}.id({arguments})")


    def distance(self, distance=None):
        """
        Source · If distance is specified, sets the distance accessor to the specified number
        or function, re-evaluates the distance accessor for each link, and returns this force.
        If distance is not specified, returns the current distance accessor, which defaults to:
        .. code:: javascript

            function distance() {
              return 30;
            }

        The distance accessor is invoked for each link, being passed the link and its
        zero-based index. The resulting number is then stored internally, such that the
        distance of each link is only recomputed when the force is initialized or when this
        method is called with a new distance, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/link#link_distance>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (distance,))))
        return forceLink(content=f"{self.content}.distance({arguments})")


    def strength(self, strength=None):
        """
        Source · If strength is specified, sets the strength accessor to the specified number
        or function, re-evaluates the strength accessor for each link, and returns this force.
        If strength is not specified, returns the current strength accessor, which defaults to:
        .. code:: javascript

            function strength(link) {
              return 1 / Math.min(count(link.source), count(link.target));
            }

        Where count(node) is a function that returns the number of links with the given node as
        a source or target. This default was chosen because it automatically reduces the
        strength of links connected to heavily-connected nodes, improving stability.
        The strength accessor is invoked for each link, being passed the link and its
        zero-based index. The resulting number is then stored internally, such that the
        strength of each link is only recomputed when the force is initialized or when this
        method is called with a new strength, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/link#link_strength>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (strength,))))
        return forceLink(content=f"{self.content}.strength({arguments})")


    def iterations(self, iterations=None):
        """
        Source · If iterations is specified, sets the number of iterations per application to
        the specified number and returns this force. If iterations is not specified, returns
        the current iteration count which defaults to 1. Increasing the number of iterations
        greatly increases the rigidity of the constraint and is useful for complex structures
        such as lattices, but also increases the runtime cost to evaluate the force.

        See more informations `here <https://d3js.org/d3-force/link#link_iterations>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (iterations,))))
        return forceLink(content=f"{self.content}.iterations({arguments})")

