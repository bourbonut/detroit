# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class forceCollide:
    def __init__(self, content="forceCollide"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def radius(self, radius=None):
        """
        Source · If radius is specified, sets the radius accessor to the specified number or
        function, re-evaluates the radius accessor for each node, and returns this force. If
        radius is not specified, returns the current radius accessor, which defaults to:
        .. code:: javascript

            function radius() {
              return 1;
            }

        The radius accessor is invoked for each node in the simulation, being passed the node
        and its zero-based index. The resulting number is then stored internally, such that the
        radius of each node is only recomputed when the force is initialized or when this
        method is called with a new radius, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/collide#collide_radius>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (radius,))))
        return forceCollide(content=f"{self.content}.radius({arguments})")


    def strength(self, strength=None):
        """
        Source · If strength is specified, sets the force strength to the specified number in
        the range [0,1] and returns this force. If strength is not specified, returns the
        current strength which defaults to 1.
        Overlapping nodes are resolved through iterative relaxation. For each node, the other
        nodes that are anticipated to overlap at the next tick (using the anticipated positions
        ⟨x + vx,y + vy⟩) are determined; the node’s velocity is then modified to push the node
        out of each overlapping node. The change in velocity is dampened by the force’s
        strength such that the resolution of simultaneous overlaps can be blended together to
        find a stable solution.

        See more informations `here <https://d3js.org/d3-force/collide#collide_strength>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (strength,))))
        return forceCollide(content=f"{self.content}.strength({arguments})")


    def iterations(self, iterations=None):
        """
        Source · If iterations is specified, sets the number of iterations per application to
        the specified number and returns this force. If iterations is not specified, returns
        the current iteration count which defaults to 1. Increasing the number of iterations
        greatly increases the rigidity of the constraint and avoids partial overlap of nodes,
        but also increases the runtime cost to evaluate the force.

        See more informations `here <https://d3js.org/d3-force/collide#collide_iterations>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (iterations,))))
        return forceCollide(content=f"{self.content}.iterations({arguments})")

