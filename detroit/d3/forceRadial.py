# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class forceRadial:
    def __init__(self, content="forceRadial"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def strength(self, strength=None):
        """
        Source · If strength is specified, sets the strength accessor to the specified number
        or function, re-evaluates the strength accessor for each node, and returns this force.
        The strength determines how much to increment the node’s x- and y-velocity. For
        example, a value of 0.1 indicates that the node should move a tenth of the way from its
        current position to the closest point on the circle with each application. Higher
        values moves nodes more quickly to the target position, often at the expense of other
        forces or constraints. A value outside the range [0,1] is not recommended.
        If strength is not specified, returns the current strength accessor, which defaults to:
        .. code:: javascript

            function strength() {
              return 0.1;
            }

        The strength accessor is invoked for each node in the simulation, being passed the node
        and its zero-based index. The resulting number is then stored internally, such that the
        strength of each node is only recomputed when the force is initialized or when this
        method is called with a new strength, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/position#radial_strength>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (strength,))))
        return forceRadial(content=f"{self.content}.strength({arguments})")


    def radius(self, radius=None):
        """
        Source · If radius is specified, sets the circle radius to the specified number or
        function, re-evaluates the radius accessor for each node, and returns this force. If
        radius is not specified, returns the current radius accessor.
        The radius accessor is invoked for each node in the simulation, being passed the node
        and its zero-based index. The resulting number is then stored internally, such that the
        target radius of each node is only recomputed when the force is initialized or when
        this method is called with a new radius, and not on every application of the force.

        See more informations `here <https://d3js.org/d3-force/position#radial_radius>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (radius,))))
        return forceRadial(content=f"{self.content}.radius({arguments})")


    def x(self, x=None):
        """
        Source · If x is specified, sets the x-coordinate of the circle center to the specified
        number and returns this force. If x is not specified, returns the current x-coordinate
        of the center, which defaults to zero.

        See more informations `here <https://d3js.org/d3-force/position#radial_x>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (x,))))
        return forceRadial(content=f"{self.content}.x({arguments})")


    def y(self, y=None):
        """
        Source · If y is specified, sets the y coordinate of the circle center to the specified
        number and returns this force. If y is not specified, returns the current y coordinate
        of the center, which defaults to zero.

        See more informations `here <https://d3js.org/d3-force/position#radial_y>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (y,))))
        return forceRadial(content=f"{self.content}.y({arguments})")

