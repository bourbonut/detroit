# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class node:
    def __init__(self, content="node"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def ancestors(self):
        """
        Source · Returns the array of ancestors nodes, starting with this node, then followed
        by each parent up to the root.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_ancestors>`_.
        """
        return node(content=f"{self.content}.ancestors()")


    def descendants(self):
        """
        Source · Returns the array of descendant nodes, starting with this node, then followed
        by each child in topological order.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_descendants>`_.
        """
        return node(content=f"{self.content}.descendants()")


    def leaves(self):
        """
        Source · Returns the array of leaf nodes in traversal order. A leaf is a node with no
        children.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_leaves>`_.
        """
        return node(content=f"{self.content}.leaves()")


    def find(self, filter=None):
        """
        Source · Returns the first node in the hierarchy from this node for which the specified
        filter returns a truthy value. Returns undefined if no such node is found.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_find>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (filter,))))
        return node(content=f"{self.content}.find({arguments})")


    def path(self, target=None):
        """
        Source · Returns the shortest path through the hierarchy from this node to the
        specified target node. The path starts at this node, ascends to the least common
        ancestor of this node and the target node, and then descends to the target node. This
        is useful for hierarchical edge bundling.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_path>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (target,))))
        return node(content=f"{self.content}.path({arguments})")


    def links(self):
        """
        Source · Returns an array of links for this node and its descendants, where each link
        is an object that defines source and target properties. The source of each link is the
        parent node, and the target is a child node.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_links>`_.
        """
        return node(content=f"{self.content}.links()")


    def sum(self, value=None):
        """
        Examples · Source · Evaluates the specified value function for this node and each
        descendant in post-order traversal, and returns this node. The node.value property of
        each node is set to the numeric value returned by the specified function plus the
        combined value of all children. The function is passed the node’s data, and must return
        a non-negative number. The value accessor is evaluated for node and every descendant,
        including internal nodes; if you only want leaf nodes to have internal value, then
        return zero for any node with children. For example, as an alternative to node.count:
        .. code:: javascript

            root.sum((d) => d.value ? 1 : 0);

        You must call node.sum or node.count before invoking a hierarchical layout that
        requires node.value, such as treemap. For example:
        .. code:: javascript

            // Construct the treemap layout.
            const treemap = d3.treemap();
            treemap.size([width, height]);
            treemap.padding(2);

            // Sum and sort the data.
            root.sum((d) => d.value);
            root.sort((a, b) => b.height - a.height || b.value - a.value);

            // Compute the treemap layout.
            treemap(root);

            // Retrieve all descendant nodes.
            const nodes = root.descendants();

        Since the API supports method chaining, you can also say:
        .. code:: javascript

            d3.treemap()
                .size([width, height])
                .padding(2)
              (root
                  .sum((d) => d.value)
                  .sort((a, b) => b.height - a.height || b.value - a.value))
              .descendants()

        This example assumes that the node data has a value field.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_sum>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (value,))))
        return node(content=f"{self.content}.sum({arguments})")


    def count(self):
        """
        Examples · Source · Computes the number of leaves under this node and assigns it to
        node.value, and similarly for every descendant of node. If this node is a leaf, its
        count is one. Returns this node. See also node.sum.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_count>`_.
        """
        return node(content=f"{self.content}.count()")


    def sort(self, compare=None):
        """
        Examples · Source · Sorts the children of this node, if any, and each of this node’s
        descendants’ children, in pre-order traversal using the specified compare function, and
        returns this node.
        The specified function is passed two nodes a and b to compare. If a should be before b,
        the function must return a value less than zero; if b should be before a, the function
        must return a value greater than zero; otherwise, the relative order of a and b are not
        specified. See array.sort for more.
        Unlike node.sum, the compare function is passed two nodes rather than two nodes’ data.
        For example, if the data has a value property, this sorts nodes by the descending
        aggregate value of the node and all its descendants, as is recommended for
        circle-packing:
        .. code:: javascript

            root
                .sum((d) => d.value)
                .sort((a, b) => b.value - a.value);

        Similarly, to sort nodes by descending height (greatest distance from any descendant
        leaf) and then descending value, as is recommended for treemaps and icicles:
        .. code:: javascript

            root
                .sum((d) => d.value)
                .sort((a, b) => b.height - a.height || b.value - a.value);

        To sort nodes by descending height and then ascending id, as is recommended for trees
        and dendrograms:
        .. code:: javascript

            root
                .sum((d) => d.value)
                .sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));

        You must call node.sort before invoking a hierarchical layout if you want the new sort
        order to affect the layout; see node.sum for an example.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_sort>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (compare,))))
        return node(content=f"{self.content}.sort({arguments})")


    def each(self, function=None, that=None):
        """
        Examples · Source · Invokes the specified function for node and each descendant in
        breadth-first order, such that a given node is only visited if all nodes of lesser
        depth have already been visited, as well as all preceding nodes of the same depth. The
        specified function is passed the current descendant, the zero-based traversal index,
        and this node. If that is specified, it is the this context of the callback.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_each>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function, that))))
        return node(content=f"{self.content}.each({arguments})")


    def eachAfter(self, function=None, that=None):
        """
        Examples · Source · Invokes the specified function for node and each descendant in
        post-order traversal, such that a given node is only visited after all of its
        descendants have already been visited. The specified function is passed the current
        descendant, the zero-based traversal index, and this node. If that is specified, it is
        the this context of the callback.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_eachAfter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function, that))))
        return node(content=f"{self.content}.eachAfter({arguments})")


    def eachBefore(self, function=None, that=None):
        """
        Examples · Source · Invokes the specified function for node and each descendant in
        pre-order traversal, such that a given node is only visited after all of its ancestors
        have already been visited. The specified function is passed the current descendant, the
        zero-based traversal index, and this node. If that is specified, it is the this context
        of the callback.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_eachBefore>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (function, that))))
        return node(content=f"{self.content}.eachBefore({arguments})")


    def copy(self):
        """
        Source · Return a deep copy of the subtree starting at this node. (The returned deep
        copy shares the same data, however.) The returned node is the root of a new tree; the
        returned node’s parent is always null and its depth is always zero.

        See more informations `here <https://d3js.org/d3-hierarchy/hierarchy#node_copy>`_.
        """
        return node(content=f"{self.content}.copy()")

