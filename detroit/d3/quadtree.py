# Generated by detroit
# See https://github.com/bourbonut/detroit/tree/main/api_maker

from functools import partial
from operator import is_not

class quadtree:
    def __init__(self, content="quadtree"):
        self.content = content

    def __repr__(self):
        return self.content

    def __str__(self):
        return self.content

    def __call__(self, *args):
        arguments = ", ".join(map(repr, args))
        return f"{self}({arguments})"

    def x(self, x=None):
        """
        Source · If x is specified, sets the current x-coordinate accessor and returns the
        quadtree.
        .. code:: javascript

            const tree = d3.quadtree().x((d) => d.x);

        The x accessor is used to derive the x coordinate of data when adding to and removing
        from the tree. It is also used when finding to re-access the coordinates of data
        previously added to the tree; therefore, the x and y accessors must be consistent,
        returning the same value given the same input.
        If x is not specified, returns the current x accessor.
        .. code:: javascript

            tree.x() // (d) => d.x

        The x accessor defaults to:
        .. code:: javascript

            function x(d) {
              return d[0];
            }


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_x>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (x,))))
        return quadtree(content=f"{self.content}.x({arguments})")


    def y(self, y=None):
        """
        Source · If y is specified, sets the current y-coordinate accessor and returns the
        quadtree.
        .. code:: javascript

            const tree = d3.quadtree().y((d) => d.y);

        The y accessor is used to derive the y coordinate of data when adding to and removing
        from the tree. It is also used when finding to re-access the coordinates of data
        previously added to the tree; therefore, the x and y accessors must be consistent,
        returning the same value given the same input.
        If y is not specified, returns the current y accessor.
        .. code:: javascript

            tree.y() // (d) => d.y

        The y accessor defaults to:
        .. code:: javascript

            function y(d) {
              return d[1];
            }


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_y>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (y,))))
        return quadtree(content=f"{self.content}.y({arguments})")


    def extent(self, extent=None):
        """
        Source · If extent is specified, expands the quadtree to cover the specified points
        [[x0, y0], [x1, y1]] and returns the quadtree.
        .. code:: javascript

            const tree = d3.quadtree().extent([[0, 0], [1, 1]]);

        If extent is not specified, returns the quadtree’s current extent [[x0, y0], [x1, y1]],
        where x0 and y0 are the inclusive lower bounds and x1 and y1 are the inclusive upper
        bounds, or undefined if the quadtree has no extent.
        .. code:: javascript

            tree.extent() // [[0, 0], [2, 2]]

        The extent may also be expanded by calling quadtree.cover or quadtree.add.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_extent>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (extent,))))
        return quadtree(content=f"{self.content}.extent({arguments})")


    def cover(self, x=None, y=None):
        """
        Source · Expands the quadtree to cover the specified point ⟨x,y⟩, and returns the
        quadtree.
        .. code:: javascript

            const tree = d3.quadtree().cover(0, 0).cover(1, 1);

        If the quadtree’s extent already covers the specified point, this method does nothing.
        If the quadtree has an extent, the extent is repeatedly doubled to cover the specified
        point, wrapping the root node as necessary; if the quadtree is empty, the extent is
        initialized to the extent [[⌊x⌋, ⌊y⌋], [⌈x⌉, ⌈y⌉]]. (Rounding is necessary such that if
        the extent is later doubled, the boundaries of existing quadrants do not change due to
        floating point error.)

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_cover>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (x, y))))
        return quadtree(content=f"{self.content}.cover({arguments})")


    def add(self, datum=None):
        """
        Source · Adds the specified datum to the quadtree, deriving its coordinates ⟨x,y⟩ using
        the current x and y accessors, and returns the quadtree.
        .. code:: javascript

            const tree = d3.quadtree().add([0, 0]);

        If the new point is outside the current extent of the quadtree, the quadtree is
        automatically expanded to cover the new point.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_add>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (datum,))))
        return quadtree(content=f"{self.content}.add({arguments})")


    def addAll(self, data=None):
        """
        Source · Adds the specified iterable of data to the quadtree, deriving each element’s
        coordinates ⟨x,y⟩ using the current x and y accessors, and return this quadtree.
        .. code:: javascript

            const tree = d3.quadtree().addAll([[0, 0], [1, 2]]);

        This is approximately equivalent to calling quadtree.add repeatedly:
        .. code:: javascript

            for (let i = 0, n = data.length; i < n; ++i) {
              quadtree.add(data[i]);
            }

        However, this method results in a more compact quadtree because the extent of the data
        is computed first before adding the data.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_addAll>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data,))))
        return quadtree(content=f"{self.content}.addAll({arguments})")


    def remove(self, datum=None):
        """
        Source · Removes the specified datum from the quadtree, deriving its coordinates ⟨x,y⟩
        using the current x and y accessors, and returns the quadtree.
        .. code:: javascript

            tree.remove(data[0]);

        If the specified datum does not exist in this quadtree (as determined by strict
        equality with datum, and independent of the computed position), this method does
        nothing.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_remove>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (datum,))))
        return quadtree(content=f"{self.content}.remove({arguments})")


    def removeAll(self, data=None):
        """
        Source · Removes the specified data from the quadtree, deriving their coordinates ⟨x,y⟩
        using the current x and y accessors, and returns the quadtree.
        .. code:: javascript

            tree.removeAll(data);

        If a specified datum does not exist in this quadtree (as determined by strict equality
        with datum, and independent of the computed position), it is ignored.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_removeAll>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (data,))))
        return quadtree(content=f"{self.content}.removeAll({arguments})")


    def copy(self):
        """
        .. code:: javascript

            const t1 = d3.quadtree(data);
            const t2 = t1.copy();

        Source · Returns a copy of the quadtree. All nodes in the returned quadtree are
        identical copies of the corresponding node in the quadtree; however, any data in the
        quadtree is shared by reference and not copied.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_copy>`_.
        """
        return quadtree(content=f"{self.content}.copy()")


    def root(self):
        """
        Source · Returns the root node of the quadtree.
        .. code:: javascript

            tree.root() // [{…}, empty × 2, {…}]


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_root>`_.
        """
        return quadtree(content=f"{self.content}.root()")


    def data(self):
        """
        Source · Returns an array of all data in the quadtree.
        .. code:: javascript

            tree.data() // [[0, 0], [1, 2]]


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_data>`_.
        """
        return quadtree(content=f"{self.content}.data()")


    def size(self):
        """
        Source · Returns the total number of data in the quadtree.
        .. code:: javascript

            tree.size() // 2


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_size>`_.
        """
        return quadtree(content=f"{self.content}.size()")


    def find(self, x=None, y=None, radius=None):
        """
        Source · Returns the datum closest to the position ⟨x,y⟩ with the given search radius.
        If radius is not specified, it defaults to infinity.
        .. code:: javascript

            tree.find(0.000, 0.000) // 

        If there is no datum within the search area, returns undefined.
        .. code:: javascript

            tree.find(10, 10, 1) // undefined


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_find>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (x, y, radius))))
        return quadtree(content=f"{self.content}.find({arguments})")


    def visit(self, callback=None):
        """
        Source · Visits each node in the quadtree in pre-order traversal, invoking the
        specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the
        node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the
        upper bounds, and returns the quadtree. (Assuming that positive x is right and positive
        y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner
        and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so
        more formally x0 <= x1 and y0 <= y1.)
        If the callback returns true for a given node, then the children of that node are not
        visited; otherwise, all child nodes are visited. This can be used to quickly visit only
        parts of the tree, for example when using the Barnes–Hut approximation. Note, however,
        that child quadrants are always visited in sibling order: top-left, top-right,
        bottom-left, bottom-right. In cases such as search, visiting siblings in a specific
        order may be faster.
        As an example, the following visits the quadtree and returns all the nodes within a
        rectangular extent [xmin, ymin, xmax, ymax], ignoring quads that cannot possibly
        contain any such node:
        .. code:: javascript

            function search(quadtree, xmin, ymin, xmax, ymax) {
              const results = [];
              quadtree.visit((node, x1, y1, x2, y2) => {
                if (!node.length) {
                  do {
                    let d = node.data;
                    if (d[0] >= xmin && d[0] < xmax && d[1] >= ymin && d[1] < ymax) {
                      results.push(d);
                    }
                  } while (node = node.next);
                }
                return x1 >= xmax || y1 >= ymax || x2 < xmin || y2 < ymin;
              });
              return results;
            }


        See more informations `here <https://d3js.org/d3-quadtree#quadtree_visit>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (callback,))))
        return quadtree(content=f"{self.content}.visit({arguments})")


    def visitAfter(self, callback=None):
        """
        Source · Visits each node in the quadtree in post-order traversal, invoking the
        specified callback with arguments node, x0, y0, x1, y1 for each node, where node is the
        node being visited, ⟨x0, y0⟩ are the lower bounds of the node, and ⟨x1, y1⟩ are the
        upper bounds, and returns the quadtree. (Assuming that positive x is right and positive
        y is down, as is typically the case in Canvas and SVG, ⟨x0, y0⟩ is the top-left corner
        and ⟨x1, y1⟩ is the lower-right corner; however, the coordinate system is arbitrary, so
        more formally x0 <= x1 and y0 <= y1.) Returns root.

        See more informations `here <https://d3js.org/d3-quadtree#quadtree_visitAfter>`_.
        """
        arguments = ", ".join(map(repr, filter(partial(is_not, None), (callback,))))
        return quadtree(content=f"{self.content}.visitAfter({arguments})")

